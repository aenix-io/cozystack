diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache/watcher_cache.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache/watcher_cache.go
index fa38d6ba6..f57d6f65c 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache/watcher_cache.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache/watcher_cache.go
@@ -131,7 +131,7 @@ type NamespacedResourceWatcherCacheConfig struct {
 	OnResyncFunc ResyncFunc
 
 	// These funcs are needed to manipulate API-specific objects, such as flux's
-	// sourcev1beta2.HelmRepository, in a generic fashion
+	// sourcev1.HelmRepository, in a generic fashion
 	NewObjFunc    NewObjectFunc
 	NewListFunc   NewObjectListFunc
 	ListItemsFunc GetListItemsFunc
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart.go
index 58aae6e88..c0d62a9a7 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart.go
@@ -12,7 +12,7 @@ import (
 	"strings"
 
 	"github.com/bufbuild/connect-go"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/common"
@@ -27,12 +27,12 @@ import (
 	"sigs.k8s.io/yaml"
 )
 
-func (s *Server) getChartInCluster(ctx context.Context, headers http.Header, key types.NamespacedName) (*sourcev1beta2.HelmChart, error) {
+func (s *Server) getChartInCluster(ctx context.Context, headers http.Header, key types.NamespacedName) (*sourcev1.HelmChart, error) {
 	client, err := s.getClient(headers, key.Namespace)
 	if err != nil {
 		return nil, err
 	}
-	var chartObj sourcev1beta2.HelmChart
+	var chartObj sourcev1.HelmChart
 	if err = client.Get(ctx, key, &chartObj); err != nil {
 		return nil, connecterror.FromK8sError("get", "HelmChart", key.String(), err)
 	}
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_integration_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_integration_test.go
index 2c16c88ec..95455476f 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_integration_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_integration_test.go
@@ -12,7 +12,7 @@ import (
 	"testing"
 	"time"
 
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	grpc_retry "github.com/grpc-ecosystem/go-grpc-middleware/retry"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	fluxplugin "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/plugins/fluxv2/packages/v1alpha1"
@@ -329,12 +329,12 @@ func TestKindClusterRepoAndChartRBAC(t *testing.T) {
 	rules := map[string][]rbacv1.PolicyRule{
 		names[1].Namespace: {
 			{
-				APIGroups: []string{sourcev1beta2.GroupVersion.Group},
+				APIGroups: []string{sourcev1.GroupVersion.Group},
 				Resources: []string{fluxHelmRepositories},
 				Verbs:     []string{"get", "list"},
 			},
 			{
-				APIGroups: []string{sourcev1beta2.GroupVersion.Group},
+				APIGroups: []string{sourcev1.GroupVersion.Group},
 				Resources: []string{"helmcharts"},
 				Verbs:     []string{"get", "list"},
 			},
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_test.go
index 7641d5c77..362fc82ef 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/chart_test.go
@@ -16,7 +16,7 @@ import (
 	"github.com/bufbuild/connect-go"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/go-redis/redismock/v8"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache"
@@ -187,7 +187,7 @@ func TestGetAvailablePackageDetail(t *testing.T) {
 			}
 			defer ts2.Close()
 
-			s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, charts, secretObjs)
+			s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, charts, secretObjs)
 			if err != nil {
 				t.Fatalf("%+v", err)
 			}
@@ -291,7 +291,7 @@ func TestTransientHttpFailuresAreRetriedForChartCache(t *testing.T) {
 		}
 		defer ts2.Close()
 
-		s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, charts, nil)
+		s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, charts, nil)
 		if err != nil {
 			t.Fatalf("%+v", err)
 		}
@@ -468,7 +468,7 @@ func TestNonExistingRepoOrInvalidPkgVersionGetAvailablePackageDetail(t *testing.
 			}
 			defer ts2.Close()
 
-			s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, charts, nil)
+			s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, charts, nil)
 			if err != nil {
 				t.Fatalf("%+v", err)
 			}
@@ -649,7 +649,7 @@ func TestGetAvailablePackageVersions(t *testing.T) {
 			}
 			defer ts.Close()
 
-			s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, charts, nil)
+			s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, charts, nil)
 			if err != nil {
 				t.Fatalf("%+v", err)
 			}
@@ -736,7 +736,7 @@ func TestGetOciAvailablePackageVersions(t *testing.T) {
 				t.Fatal(err)
 			}
 
-			s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, tc.charts, nil)
+			s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, tc.charts, nil)
 			if err != nil {
 				t.Fatalf("%+v", err)
 			}
@@ -979,12 +979,12 @@ func TestChartWithRelativeURL(t *testing.T) {
 		}
 	}))
 
-	repoSpec := &sourcev1beta2.HelmRepositorySpec{
+	repoSpec := &sourcev1.HelmRepositorySpec{
 		URL:      ts.URL,
 		Interval: metav1.Duration{Duration: 1 * time.Minute},
 	}
 
-	repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+	repoStatus := &sourcev1.HelmRepositoryStatus{
 		Artifact: &sourcev1.Artifact{
 			Digest:         "651f952130ea96823711d08345b85e82be011dc6",
 			LastUpdateTime: metav1.Time{Time: lastUpdateTime},
@@ -1003,7 +1003,7 @@ func TestChartWithRelativeURL(t *testing.T) {
 	defer ts.Close()
 
 	s, mock, err := newServerWithRepos(t,
-		[]sourcev1beta2.HelmRepository{repo},
+		[]sourcev1.HelmRepository{repo},
 		[]testSpecChartWithUrl{
 			{
 				chartID:       fmt.Sprintf("%s/airflow", repoName),
@@ -1073,7 +1073,7 @@ func TestGetOciAvailablePackageDetail(t *testing.T) {
 				t.Fatal(err)
 			}
 
-			s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, tc.charts, nil)
+			s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, tc.charts, nil)
 			if err != nil {
 				t.Fatalf("%+v", err)
 			}
@@ -1129,8 +1129,8 @@ func TestGetOciAvailablePackageDetail(t *testing.T) {
 	}
 }
 
-func newChart(name, namespace string, spec *sourcev1beta2.HelmChartSpec, status *sourcev1beta2.HelmChartStatus) sourcev1beta2.HelmChart {
-	helmChart := sourcev1beta2.HelmChart{
+func newChart(name, namespace string, spec *sourcev1.HelmChartSpec, status *sourcev1.HelmChartStatus) sourcev1.HelmChart {
+	helmChart := sourcev1.HelmChart{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:       name,
 			Generation: int64(1),
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/common/utils.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/common/utils.go
index cdb3611b0..5d5f5433b 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/common/utils.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/common/utils.go
@@ -24,8 +24,8 @@ import (
 	"github.com/bufbuild/connect-go"
 	"github.com/docker/cli/cli/config"
 	"github.com/docker/cli/cli/config/credentials"
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/go-redis/redis/v8"
 	"github.com/google/go-containerregistry/pkg/authn"
 	plugins "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/plugins/v1alpha1"
@@ -68,20 +68,20 @@ func init() {
 	}
 
 	repositoriesGvr = schema.GroupVersionResource{
-		Group:    sourcev1beta2.GroupVersion.Group,
-		Version:  sourcev1beta2.GroupVersion.Version,
+		Group:    sourcev1.GroupVersion.Group,
+		Version:  sourcev1.GroupVersion.Version,
 		Resource: "helmrepositories",
 	}
 
 	chartsGvr = schema.GroupVersionResource{
-		Group:    sourcev1beta2.GroupVersion.Group,
-		Version:  sourcev1beta2.GroupVersion.Version,
+		Group:    sourcev1.GroupVersion.Group,
+		Version:  sourcev1.GroupVersion.Version,
 		Resource: "helmcharts",
 	}
 
 	releasesGvr = schema.GroupVersionResource{
-		Group:    helmv2beta2.GroupVersion.Group,
-		Version:  helmv2beta2.GroupVersion.Version,
+		Group:    helmv2.GroupVersion.Group,
+		Version:  helmv2.GroupVersion.Version,
 		Resource: "helmreleases",
 	}
 }
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/global_vars_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/global_vars_test.go
index e3c1880a5..556516068 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/global_vars_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/global_vars_test.go
@@ -10,10 +10,10 @@ import (
 
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/pkg/k8sutils"
 
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/plugins/fluxv2/packages/v1alpha1"
 	"google.golang.org/protobuf/types/known/anypb"
@@ -1006,33 +1006,33 @@ var (
 		},
 	}
 
-	add_repo_1 = sourcev1beta2.HelmRepository{
+	add_repo_1 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 		},
 	}
 
-	add_repo_2 = sourcev1beta2.HelmRepository{
+	add_repo_2 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 			// TODO(agamez): flux upgrade - migrate to CertSecretRef, see https://github.com/fluxcd/flux2/releases/tag/v2.1.0
@@ -1040,17 +1040,17 @@ var (
 		},
 	}
 
-	add_repo_3 = sourcev1beta2.HelmRepository{
+	add_repo_3 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 			// TODO(agamez): flux upgrade - migrate to CertSecretRef, see https://github.com/fluxcd/flux2/releases/tag/v2.1.0
@@ -1058,17 +1058,17 @@ var (
 		},
 	}
 
-	add_repo_4 = sourcev1beta2.HelmRepository{
+	add_repo_4 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 			// TODO(agamez): flux upgrade - migrate to CertSecretRef, see https://github.com/fluxcd/flux2/releases/tag/v2.1.0
@@ -1077,51 +1077,51 @@ var (
 		},
 	}
 
-	add_repo_5 = sourcev1beta2.HelmRepository{
+	add_repo_5 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:             "http://example.com",
 			Interval:        metav1.Duration{Duration: 10 * time.Minute},
 			PassCredentials: true,
 		},
 	}
 
-	add_repo_6 = sourcev1beta2.HelmRepository{
+	add_repo_6 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      github_stefanprodan_podinfo_oci_registry_url,
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 			Type:     "oci",
 		},
 	}
 
-	add_repo_7 = sourcev1beta2.HelmRepository{
+	add_repo_7 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
 			Namespace:       "foo",
 			ResourceVersion: "1",
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      github_stefanprodan_podinfo_oci_registry_url,
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 			Type:     "oci",
@@ -1129,10 +1129,10 @@ var (
 		},
 	}
 
-	add_repo_8 = sourcev1beta2.HelmRepository{
+	add_repo_8 = sourcev1.HelmRepository{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       sourcev1beta2.HelmRepositoryKind,
-			APIVersion: sourcev1beta2.GroupVersion.String(),
+			Kind:       sourcev1.HelmRepositoryKind,
+			APIVersion: sourcev1.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "bar",
@@ -1140,7 +1140,7 @@ var (
 			ResourceVersion: "1",
 			Annotations:     map[string]string{k8sutils.AnnotationDescriptionKey: "repo desc"},
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 		},
@@ -1831,7 +1831,7 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -1844,7 +1844,7 @@ var (
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionTrue,
-					Reason:             helmv2beta2.InstallSucceededReason,
+					Reason:             helmv2.InstallSucceededReason,
 					Message:            "Helm install succeeded",
 				},
 			},
@@ -1886,7 +1886,7 @@ var (
 		releaseSuspend:            true,
 		releaseServiceAccountName: "foo",
 		releaseValues:             &v1.JSON{Raw: redis_existing_spec_completed_with_values_and_reconciliation_options_values_bytes},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -1899,7 +1899,7 @@ var (
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionTrue,
-					Reason:             helmv2beta2.InstallSucceededReason,
+					Reason:             helmv2.InstallSucceededReason,
 					Message:            "Helm install succeeded",
 				},
 			},
@@ -1923,20 +1923,20 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               fluxmeta.ReadyCondition,
 					Status:             metav1.ConditionFalse,
-					Reason:             helmv2beta2.InstallFailedReason,
+					Reason:             helmv2.InstallFailedReason,
 					Message:            "install retries exhausted",
 				},
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionFalse,
-					Reason:             helmv2beta2.InstallFailedReason,
+					Reason:             helmv2.InstallFailedReason,
 					Message:            "Helm install failed: unable to build kubernetes objects from release manifest: error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"",
 				},
 			},
@@ -1961,13 +1961,13 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               fluxmeta.ReadyCondition,
 					Status:             metav1.ConditionFalse,
-					Reason:             helmv2beta2.GetLastReleaseFailedReason,
+					Reason:             helmv2.GetLastReleaseFailedReason,
 					Message:            "failed to get last release revision",
 				},
 			},
@@ -1990,13 +1990,13 @@ var (
 			Namespace:  "test",
 			Generation: 2,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               fluxmeta.ReadyCondition,
 					Status:             metav1.ConditionFalse,
-					Reason:             helmv2beta2.GetLastReleaseFailedReason,
+					Reason:             helmv2.GetLastReleaseFailedReason,
 					Message:            "failed to get last release revision",
 				},
 			},
@@ -2027,7 +2027,7 @@ var (
 			Namespace:  "namespace-2",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2040,7 +2040,7 @@ var (
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionTrue,
-					Reason:             helmv2beta2.InstallSucceededReason,
+					Reason:             helmv2.InstallSucceededReason,
 					Message:            "Helm install succeeded",
 				},
 			},
@@ -2064,7 +2064,7 @@ var (
 			Namespace:  "namespace-2",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2077,7 +2077,7 @@ var (
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionTrue,
-					Reason:             helmv2beta2.InstallSucceededReason,
+					Reason:             helmv2.InstallSucceededReason,
 					Message:            "Helm install succeeded",
 				},
 			},
@@ -2101,7 +2101,7 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2130,13 +2130,13 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               fluxmeta.ReadyCondition,
 					Status:             metav1.ConditionFalse,
-					Reason:             helmv2beta2.ArtifactFailedReason,
+					Reason:             helmv2.ArtifactFailedReason,
 					Message:            "HelmChart 'default/kubeapps-my-redis' is not ready",
 				},
 			},
@@ -2168,7 +2168,7 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2181,7 +2181,7 @@ var (
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionTrue,
-					Reason:             helmv2beta2.InstallSucceededReason,
+					Reason:             helmv2.InstallSucceededReason,
 					Message:            "Helm install succeeded",
 				},
 			},
@@ -2275,41 +2275,41 @@ var (
 		PostInstallationNotes: "some notes",
 	}
 
-	flux_helm_release_basic = newFluxHelmRelease(helmv2beta2.HelmChartTemplateSpec{
+	flux_helm_release_basic = newFluxHelmRelease(helmv2.HelmChartTemplateSpec{
 		Chart: "podinfo",
-		SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-			Kind:      sourcev1beta2.HelmRepositoryKind,
+		SourceRef: helmv2.CrossNamespaceObjectReference{
+			Kind:      sourcev1.HelmRepositoryKind,
 			Name:      "podinfo",
 			Namespace: "namespace-1",
 		},
 	})
 
-	flux_helm_release_semver_constraint = newFluxHelmRelease(helmv2beta2.HelmChartTemplateSpec{
+	flux_helm_release_semver_constraint = newFluxHelmRelease(helmv2.HelmChartTemplateSpec{
 		Chart: "podinfo",
-		SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-			Kind:      sourcev1beta2.HelmRepositoryKind,
+		SourceRef: helmv2.CrossNamespaceObjectReference{
+			Kind:      sourcev1.HelmRepositoryKind,
 			Name:      "podinfo",
 			Namespace: "namespace-1",
 		},
 		Version: "> 5",
 	})
 
-	flux_helm_release_reconcile_options = &helmv2beta2.HelmRelease{
+	flux_helm_release_reconcile_options = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-podinfo",
 			Namespace:       "test",
 			ResourceVersion: "1",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart: "podinfo",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "podinfo",
 						Namespace: "namespace-1",
 					},
@@ -2327,22 +2327,22 @@ var (
 				"message": "what we do in the shadows",
 			}})
 
-	flux_helm_release_values = &helmv2beta2.HelmRelease{
+	flux_helm_release_values = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-podinfo",
 			Namespace:       "test",
 			ResourceVersion: "1",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart: "podinfo",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "podinfo",
 						Namespace: "namespace-1",
 					},
@@ -2357,10 +2357,10 @@ var (
 		InstalledPackageRef: installedRef("my-podinfo", "test"),
 	}
 
-	flux_helm_release_updated_1 = &helmv2beta2.HelmRelease{
+	flux_helm_release_updated_1 = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-redis",
@@ -2368,12 +2368,12 @@ var (
 			Generation:      int64(1),
 			ResourceVersion: "1000",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart: "redis",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "bitnami-1",
 						Namespace: "default",
 					},
@@ -2384,10 +2384,10 @@ var (
 		},
 	}
 
-	flux_helm_release_updated_2 = &helmv2beta2.HelmRelease{
+	flux_helm_release_updated_2 = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-redis",
@@ -2395,12 +2395,12 @@ var (
 			Generation:      int64(1),
 			ResourceVersion: "1000",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart: "redis",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "bitnami-1",
 						Namespace: "default",
 					},
@@ -2424,7 +2424,7 @@ var (
 			Namespace:  "test",
 			Generation: 1,
 		},
-		releaseStatus: helmv2beta2.HelmReleaseStatus{
+		releaseStatus: helmv2.HelmReleaseStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2437,7 +2437,7 @@ var (
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Type:               "Released",
 					Status:             metav1.ConditionTrue,
-					Reason:             helmv2beta2.InstallSucceededReason,
+					Reason:             helmv2.InstallSucceededReason,
 					Message:            "Helm install succeeded",
 				},
 			},
@@ -2457,10 +2457,10 @@ var (
 		status:       release.StatusDeployed,
 	}
 
-	flux_helm_release_updated_target_ns_is_set = &helmv2beta2.HelmRelease{
+	flux_helm_release_updated_target_ns_is_set = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-redis",
@@ -2468,12 +2468,12 @@ var (
 			Generation:      int64(1),
 			ResourceVersion: "1000",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart: "redis",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "bitnami-1",
 						Namespace: "default",
 					},
@@ -2661,50 +2661,50 @@ var (
 		},
 	}
 
-	flux_helm_release_upgrade_policy_none = newFluxHelmRelease(helmv2beta2.HelmChartTemplateSpec{
+	flux_helm_release_upgrade_policy_none = newFluxHelmRelease(helmv2.HelmChartTemplateSpec{
 		Chart:   "podinfo",
 		Version: "5.2.1",
-		SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-			Kind:      sourcev1beta2.HelmRepositoryKind,
+		SourceRef: helmv2.CrossNamespaceObjectReference{
+			Kind:      sourcev1.HelmRepositoryKind,
 			Name:      "podinfo",
 			Namespace: "namespace-1",
 		},
 	})
 
-	flux_helm_release_upgrade_policy_major = newFluxHelmRelease(helmv2beta2.HelmChartTemplateSpec{
+	flux_helm_release_upgrade_policy_major = newFluxHelmRelease(helmv2.HelmChartTemplateSpec{
 		Chart:   "podinfo",
 		Version: ">=5.2.1",
-		SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-			Kind:      sourcev1beta2.HelmRepositoryKind,
+		SourceRef: helmv2.CrossNamespaceObjectReference{
+			Kind:      sourcev1.HelmRepositoryKind,
 			Name:      "podinfo",
 			Namespace: "namespace-1",
 		},
 	})
 
-	flux_helm_release_upgrade_policy_minor = newFluxHelmRelease(helmv2beta2.HelmChartTemplateSpec{
+	flux_helm_release_upgrade_policy_minor = newFluxHelmRelease(helmv2.HelmChartTemplateSpec{
 		Chart:   "podinfo",
 		Version: ">=5.2.1 <6.0.0",
-		SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-			Kind:      sourcev1beta2.HelmRepositoryKind,
+		SourceRef: helmv2.CrossNamespaceObjectReference{
+			Kind:      sourcev1.HelmRepositoryKind,
 			Name:      "podinfo",
 			Namespace: "namespace-1",
 		},
 	})
 
-	flux_helm_release_upgrade_policy_patch = newFluxHelmRelease(helmv2beta2.HelmChartTemplateSpec{
+	flux_helm_release_upgrade_policy_patch = newFluxHelmRelease(helmv2.HelmChartTemplateSpec{
 		Chart:   "podinfo",
 		Version: ">=5.2.1 <5.3.0",
-		SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-			Kind:      sourcev1beta2.HelmRepositoryKind,
+		SourceRef: helmv2.CrossNamespaceObjectReference{
+			Kind:      sourcev1.HelmRepositoryKind,
 			Name:      "podinfo",
 			Namespace: "namespace-1",
 		},
 	})
 
-	flux_helm_release_updated_upgrade_major = &helmv2beta2.HelmRelease{
+	flux_helm_release_updated_upgrade_major = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-redis",
@@ -2712,13 +2712,13 @@ var (
 			Generation:      int64(1),
 			ResourceVersion: "1000",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Version: ">=14.4.0",
 					Chart:   "redis",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "bitnami-1",
 						Namespace: "default",
 					},
@@ -2728,10 +2728,10 @@ var (
 		},
 	}
 
-	flux_helm_release_updated_upgrade_minor = &helmv2beta2.HelmRelease{
+	flux_helm_release_updated_upgrade_minor = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-redis",
@@ -2739,13 +2739,13 @@ var (
 			Generation:      int64(1),
 			ResourceVersion: "1000",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Version: ">=14.4.0 <15.0.0",
 					Chart:   "redis",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "bitnami-1",
 						Namespace: "default",
 					},
@@ -2755,10 +2755,10 @@ var (
 		},
 	}
 
-	flux_helm_release_updated_upgrade_patch = &helmv2beta2.HelmRelease{
+	flux_helm_release_updated_upgrade_patch = &helmv2.HelmRelease{
 		TypeMeta: metav1.TypeMeta{
-			Kind:       helmv2beta2.HelmReleaseKind,
-			APIVersion: helmv2beta2.GroupVersion.String(),
+			Kind:       helmv2.HelmReleaseKind,
+			APIVersion: helmv2.GroupVersion.String(),
 		},
 		ObjectMeta: metav1.ObjectMeta{
 			Name:            "my-redis",
@@ -2766,13 +2766,13 @@ var (
 			Generation:      int64(1),
 			ResourceVersion: "1000",
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Version: ">=14.4.0 <14.5.0",
 					Chart:   "redis",
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+					SourceRef: helmv2.CrossNamespaceObjectReference{
+						Kind:      sourcev1.HelmRepositoryKind,
 						Name:      "bitnami-1",
 						Namespace: "default",
 					},
@@ -3230,13 +3230,13 @@ var (
 	}
 
 	get_summaries_repo_1 = newRepo("bar", "foo",
-		&sourcev1beta2.HelmRepositorySpec{
+		&sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 			// TODO(agamez): flux upgrade - migrate to CertSecretRef, see https://github.com/fluxcd/flux2/releases/tag/v2.1.0
 			SecretRef: &fluxmeta.LocalObjectReference{},
 		},
-		&sourcev1beta2.HelmRepositoryStatus{
+		&sourcev1.HelmRepositoryStatus{
 			Artifact: &sourcev1.Artifact{
 				Digest:         "651f952130ea96823711d08345b85e82be011dc6",
 				LastUpdateTime: metav1.Time{Time: lastUpdateTime},
@@ -3257,11 +3257,11 @@ var (
 		})
 
 	get_summaries_repo_2 = newRepo("zot", "xyz",
-		&sourcev1beta2.HelmRepositorySpec{
+		&sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 		},
-		&sourcev1beta2.HelmRepositoryStatus{
+		&sourcev1.HelmRepositoryStatus{
 			Artifact: &sourcev1.Artifact{
 				Digest:         "651f952130ea96823711d08345b85e82be011dc6",
 				LastUpdateTime: metav1.Time{Time: lastUpdateTime},
@@ -3282,19 +3282,19 @@ var (
 		})
 
 	get_summaries_repo_3 = newRepo("pending", "xyz",
-		&sourcev1beta2.HelmRepositorySpec{
+		&sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 		},
-		&sourcev1beta2.HelmRepositoryStatus{ObservedGeneration: -1},
+		&sourcev1.HelmRepositoryStatus{ObservedGeneration: -1},
 	)
 
 	get_summaries_repo_4 = newRepo("failed", "xyz",
-		&sourcev1beta2.HelmRepositorySpec{
+		&sourcev1.HelmRepositorySpec{
 			URL:      "http://example.com",
 			Interval: metav1.Duration{Duration: 10 * time.Minute},
 		},
-		&sourcev1beta2.HelmRepositoryStatus{
+		&sourcev1.HelmRepositoryStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -4027,19 +4027,19 @@ var (
 		}
 	}
 
-	newFluxHelmRelease = func(chartSpec helmv2beta2.HelmChartTemplateSpec) *helmv2beta2.HelmRelease {
-		return &helmv2beta2.HelmRelease{
+	newFluxHelmRelease = func(chartSpec helmv2.HelmChartTemplateSpec) *helmv2.HelmRelease {
+		return &helmv2.HelmRelease{
 			TypeMeta: metav1.TypeMeta{
-				Kind:       helmv2beta2.HelmReleaseKind,
-				APIVersion: helmv2beta2.GroupVersion.String(),
+				Kind:       helmv2.HelmReleaseKind,
+				APIVersion: helmv2.GroupVersion.String(),
 			},
 			ObjectMeta: metav1.ObjectMeta{
 				Name:            "my-podinfo",
 				Namespace:       "test",
 				ResourceVersion: "1",
 			},
-			Spec: helmv2beta2.HelmReleaseSpec{
-				Chart: helmv2beta2.HelmChartTemplate{
+			Spec: helmv2.HelmReleaseSpec{
+				Chart: helmv2.HelmChartTemplate{
 					Spec: chartSpec,
 				},
 				Interval: metav1.Duration{Duration: 1 * time.Minute},
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/integration_utils_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/integration_utils_test.go
index 2433a17b0..37f3c8871 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/integration_utils_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/integration_utils_test.go
@@ -18,9 +18,9 @@ import (
 	"testing"
 	"time"
 
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/go-redis/redis/v8"
 	"github.com/vmware-tanzu/kubeapps/cmd/apprepository-controller/pkg/client/clientset/versioned/scheme"
 	plugins "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/plugins/v1alpha1"
@@ -143,7 +143,7 @@ func checkEnv(t *testing.T) (fluxplugin.FluxV2PackagesServiceClient, fluxplugin.
 		}
 
 		// Check for helmrepositories left over from manual testing. This has caused me a lot grief
-		var l *sourcev1beta2.HelmRepositoryList
+		var l *sourcev1.HelmRepositoryList
 		var names []string
 		const maxWait = 25
 		for i := 0; i <= maxWait; i++ {
@@ -250,12 +250,12 @@ func kubeAddHelmRepository(t *testing.T, name types.NamespacedName, typ, url, se
 	if interval <= 0 {
 		interval = time.Duration(10 * time.Minute)
 	}
-	repo := sourcev1beta2.HelmRepository{
+	repo := sourcev1.HelmRepository{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      name.Name,
 			Namespace: name.Namespace,
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      url,
 			Interval: metav1.Duration{Duration: interval},
 		},
@@ -296,7 +296,7 @@ func kubeAddHelmRepositoryAndCleanup(t *testing.T, name types.NamespacedName, ty
 	return err
 }
 
-func kubeGetHelmRepository(t *testing.T, name types.NamespacedName) (*sourcev1beta2.HelmRepository, error) {
+func kubeGetHelmRepository(t *testing.T, name types.NamespacedName) (*sourcev1.HelmRepository, error) {
 	t.Logf("+kubeGetHelmRepository(%s)", name)
 
 	ctx, cancel := context.WithTimeout(context.Background(), defaultContextTimeout)
@@ -304,7 +304,7 @@ func kubeGetHelmRepository(t *testing.T, name types.NamespacedName) (*sourcev1be
 	if ifc, err := kubeGetCtrlClient(); err != nil {
 		return nil, err
 	} else {
-		var repo sourcev1beta2.HelmRepository
+		var repo sourcev1.HelmRepository
 		if err := ifc.Get(ctx, name, &repo); err != nil {
 			return nil, err
 		}
@@ -312,7 +312,7 @@ func kubeGetHelmRepository(t *testing.T, name types.NamespacedName) (*sourcev1be
 	}
 }
 
-func kubeListAllHelmRepositories(t *testing.T) (*sourcev1beta2.HelmRepositoryList, error) {
+func kubeListAllHelmRepositories(t *testing.T) (*sourcev1.HelmRepositoryList, error) {
 	t.Logf("+kubeListAllHelmRepositories()")
 
 	ctx, cancel := context.WithTimeout(context.Background(), defaultContextTimeout)
@@ -320,7 +320,7 @@ func kubeListAllHelmRepositories(t *testing.T) (*sourcev1beta2.HelmRepositoryLis
 	if ifc, err := kubeGetCtrlClient(); err != nil {
 		return nil, err
 	} else {
-		var repoList sourcev1beta2.HelmRepositoryList
+		var repoList sourcev1.HelmRepositoryList
 		if err := ifc.List(ctx, &repoList); err != nil {
 			return nil, err
 		}
@@ -339,7 +339,7 @@ func kubeWaitUntilHelmRepositoryIsReady(t *testing.T, name types.NamespacedName)
 	} else {
 		ctx, cancel := context.WithTimeout(context.Background(), 90*time.Second)
 		defer cancel()
-		var repoList sourcev1beta2.HelmRepositoryList
+		var repoList sourcev1.HelmRepositoryList
 		if watcher, err := ifc.Watch(ctx, &repoList); err != nil {
 			return err
 		} else {
@@ -356,8 +356,8 @@ func kubeWaitUntilHelmRepositoryIsReady(t *testing.T, name types.NamespacedName)
 				}
 				switch event.Type {
 				case watch.Added, watch.Modified:
-					if repo, ok := event.Object.(*sourcev1beta2.HelmRepository); !ok {
-						return errors.New("Could not cast to *sourcev1beta2.HelmRepository")
+					if repo, ok := event.Object.(*sourcev1.HelmRepository); !ok {
+						return errors.New("Could not cast to *sourcev1.HelmRepository")
 					} else {
 						hour, minute, second := time.Now().Clock()
 						complete, success, reason := isHelmRepositoryReady(*repo)
@@ -380,7 +380,7 @@ func kubeWaitUntilHelmRepositoryIsReady(t *testing.T, name types.NamespacedName)
 // this should eventually be replaced with flux plugin's DeleteRepository()
 func kubeDeleteHelmRepository(t *testing.T, name types.NamespacedName) error {
 	t.Logf("+kubeDeleteHelmRepository(%s)", name)
-	repo := &sourcev1beta2.HelmRepository{
+	repo := &sourcev1.HelmRepository{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      name.Name,
 			Namespace: name.Namespace,
@@ -399,7 +399,7 @@ func kubeExistsHelmRepository(t *testing.T, name types.NamespacedName) (bool, er
 	t.Logf("+kubeExistsHelmRepository(%s)", name)
 	ctx, cancel := context.WithTimeout(context.Background(), defaultContextTimeout)
 	defer cancel()
-	var repo sourcev1beta2.HelmRepository
+	var repo sourcev1.HelmRepository
 	if ifc, err := kubeGetCtrlClient(); err != nil {
 		return false, err
 	} else if err = ifc.Get(ctx, name, &repo); err == nil {
@@ -413,7 +413,7 @@ func kubeDeleteHelmRelease(t *testing.T, name types.NamespacedName) error {
 	t.Logf("+kubeDeleteHelmRelease(%s)", name)
 	ctx, cancel := context.WithTimeout(context.Background(), defaultContextTimeout)
 	defer cancel()
-	release := &helmv2beta2.HelmRelease{
+	release := &helmv2.HelmRelease{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      name.Name,
 			Namespace: name.Namespace,
@@ -430,7 +430,7 @@ func kubeExistsHelmRelease(t *testing.T, name types.NamespacedName) (bool, error
 	t.Logf("+kubeExistsHelmRelease(%s)", name)
 	ctx, cancel := context.WithTimeout(context.Background(), defaultContextTimeout)
 	defer cancel()
-	var rel helmv2beta2.HelmRelease
+	var rel helmv2.HelmRelease
 	if ifc, err := kubeGetCtrlClient(); err != nil {
 		return false, err
 	} else if err = ifc.Get(ctx, name, &rel); err == nil {
@@ -825,7 +825,7 @@ func kubeCreateSecret(t *testing.T, secret *apiv1.Secret) error {
 	return err
 }
 
-func kubeSetKubeappsManagedSecretOwnerRef(t *testing.T, secretName types.NamespacedName, ownerRepo *sourcev1beta2.HelmRepository) error {
+func kubeSetKubeappsManagedSecretOwnerRef(t *testing.T, secretName types.NamespacedName, ownerRepo *sourcev1.HelmRepository) error {
 	t.Logf("+kubeSetKubeappsManagedSecretOwnerRef(%s, %s)", secretName, ownerRepo.Name)
 	typedClient, err := kubeGetTypedClient()
 	if err != nil {
@@ -851,9 +851,9 @@ func kubeSetKubeappsManagedSecretOwnerRef(t *testing.T, secretName types.Namespa
 		*metav1.NewControllerRef(
 			ownerRepo,
 			schema.GroupVersionKind{
-				Group:   sourcev1beta2.GroupVersion.Group,
-				Version: sourcev1beta2.GroupVersion.Version,
-				Kind:    sourcev1beta2.HelmRepositoryKind,
+				Group:   sourcev1.GroupVersion.Group,
+				Version: sourcev1.GroupVersion.Version,
+				Kind:    sourcev1.HelmRepositoryKind,
 			}),
 	}
 
@@ -1028,11 +1028,11 @@ func kubeGetCtrlClient() (ctrlclient.WithWatch, error) {
 			return nil, err
 		} else {
 			scheme := runtime.NewScheme()
-			err = sourcev1beta2.AddToScheme(scheme)
+			err = sourcev1.AddToScheme(scheme)
 			if err != nil {
 				return nil, err
 			}
-			err = helmv2beta2.AddToScheme(scheme)
+			err = helmv2.AddToScheme(scheme)
 			if err != nil {
 				return nil, err
 			}
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/oci_repo.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/oci_repo.go
index 67bfa5480..149f904c4 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/oci_repo.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/oci_repo.go
@@ -47,7 +47,7 @@ import (
 
 	"github.com/fluxcd/pkg/oci/auth/login"
 	"github.com/fluxcd/pkg/version"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 
 	// OCI Registry As a Storage (ORAS)
 	orasregistryauthv2 "oras.land/oras-go/v2/registry/remote/auth"
@@ -386,7 +386,7 @@ func newRegistryClient(isLogin bool, tlsConfig *tls.Config, getterOpts []getter.
 // OCI Helm repository, which defines a source, does not produce an Artifact
 // ref https://fluxcd.io/docs/components/source/helmrepositories/#helm-oci-repository
 
-func (s *repoEventSink) onAddOciRepo(repo sourcev1beta2.HelmRepository) ([]byte, bool, error) {
+func (s *repoEventSink) onAddOciRepo(repo sourcev1.HelmRepository) ([]byte, bool, error) {
 	log.V(4).Infof("+onAddOciRepo(%s)", common.PrettyPrint(repo))
 	defer log.V(4).Info("-onAddOciRepo")
 
@@ -444,7 +444,7 @@ func (s *repoEventSink) onAddOciRepo(repo sourcev1beta2.HelmRepository) ([]byte,
 	return buf.Bytes(), true, nil
 }
 
-func (s *repoEventSink) onModifyOciRepo(key string, oldValue interface{}, repo sourcev1beta2.HelmRepository) ([]byte, bool, error) {
+func (s *repoEventSink) onModifyOciRepo(key string, oldValue interface{}, repo sourcev1.HelmRepository) ([]byte, bool, error) {
 	log.Infof("+onModifyOciRepo(%s)", common.PrettyPrint(repo))
 	defer log.Info("-onModifyOciRepo")
 
@@ -576,12 +576,12 @@ func (r *OCIChartRepository) shortRepoName(fullRepoName string) (string, error)
 	}
 }
 
-func (s *Server) newOCIChartRepositoryAndLogin(ctx context.Context, repo sourcev1beta2.HelmRepository) (*OCIChartRepository, error) {
+func (s *Server) newOCIChartRepositoryAndLogin(ctx context.Context, repo sourcev1.HelmRepository) (*OCIChartRepository, error) {
 	sink := s.newRepoEventSink()
 	return sink.newOCIChartRepositoryAndLogin(ctx, repo)
 }
 
-func (s *repoEventSink) newOCIChartRepositoryAndLogin(ctx context.Context, repo sourcev1beta2.HelmRepository) (*OCIChartRepository, error) {
+func (s *repoEventSink) newOCIChartRepositoryAndLogin(ctx context.Context, repo sourcev1.HelmRepository) (*OCIChartRepository, error) {
 	if loginOpts, getterOpts, cred, err := s.clientOptionsForOciRepo(ctx, repo); err != nil {
 		return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("Failed to create registry client: %w", err))
 	} else {
@@ -649,7 +649,7 @@ func (s *repoEventSink) newOCIChartRepositoryAndLoginWithOptions(registryURL str
 	return ociRepo, nil
 }
 
-func (s *repoEventSink) clientOptionsForOciRepo(ctx context.Context, repo sourcev1beta2.HelmRepository) ([]registry.LoginOption, []getter.Option, *orasregistryauthv2.Credential, error) {
+func (s *repoEventSink) clientOptionsForOciRepo(ctx context.Context, repo sourcev1.HelmRepository) ([]registry.LoginOption, []getter.Option, *orasregistryauthv2.Credential, error) {
 	var loginOpts []registry.LoginOption
 	var cred *orasregistryauthv2.Credential
 	getterOpts := []getter.Option{
@@ -680,7 +680,7 @@ func (s *repoEventSink) clientOptionsForOciRepo(ctx context.Context, repo source
 		}
 	}
 
-	if repo.Spec.Provider != "" && repo.Spec.Provider != sourcev1beta2.GenericOCIProvider {
+	if repo.Spec.Provider != "" && repo.Spec.Provider != "generic" {
 		ctxTimeout, cancel := context.WithTimeout(ctx, repo.Spec.Timeout.Duration)
 		defer cancel()
 
@@ -734,7 +734,7 @@ func downloadChartWithHelmGetter(tlsConfig *tls.Config, getterOptions []getter.O
 	return buf, err
 }
 
-func getOciChartModels(appNames []string, allTags map[string]TagList, ociChartRepo *OCIChartRepository, repo *sourcev1beta2.HelmRepository) ([]models.Chart, error) {
+func getOciChartModels(appNames []string, allTags map[string]TagList, ociChartRepo *OCIChartRepository, repo *sourcev1.HelmRepository) ([]models.Chart, error) {
 	charts := []models.Chart{}
 	for _, fullAppName := range appNames {
 		appName, err := ociChartRepo.shortRepoName(fullAppName)
@@ -756,7 +756,7 @@ func getOciChartModels(appNames []string, allTags map[string]TagList, ociChartRe
 	return charts, nil
 }
 
-func getOciChartModel(appName string, tags TagList, ociChartRepo *OCIChartRepository, repo *sourcev1beta2.HelmRepository) (*models.Chart, error) {
+func getOciChartModel(appName string, tags TagList, ociChartRepo *OCIChartRepository, repo *sourcev1.HelmRepository) (*models.Chart, error) {
 	// Encode repository names to store them in the database.
 	encodedAppName := url.PathEscape(appName)
 	chartID := path.Join(repo.Name, encodedAppName)
@@ -870,8 +870,8 @@ func downloadOCIChartFn(ociRepo *OCIChartRepository) func(chartID, chartUrl, cha
 }
 
 // oidcAuth generates the OIDC credential authenticator based on the specified cloud provider.
-func oidcAuth(ctx context.Context, repo sourcev1beta2.HelmRepository) (*orasregistryauthv2.Credential, error) {
-	url := strings.TrimPrefix(repo.Spec.URL, sourcev1beta2.OCIRepositoryPrefix)
+func oidcAuth(ctx context.Context, repo sourcev1.HelmRepository) (*orasregistryauthv2.Credential, error) {
+	url := strings.TrimPrefix(repo.Spec.URL, "oci://")
 	ref, err := name.ParseReference(url)
 	if err != nil {
 		return nil, fmt.Errorf("failed to parse URL '%s': %w", repo.Spec.URL, err)
@@ -888,11 +888,11 @@ func oidcAuth(ctx context.Context, repo sourcev1beta2.HelmRepository) (*orasregi
 func loginWithManager(ctx context.Context, provider, url string, ref name.Reference) (*orasregistryauthv2.Credential, error) {
 	opts := login.ProviderOptions{}
 	switch provider {
-	case sourcev1beta2.AmazonOCIProvider:
+	case "amazon":
 		opts.AwsAutoLogin = true
-	case sourcev1beta2.AzureOCIProvider:
+	case "azure":
 		opts.AzureAutoLogin = true
-	case sourcev1beta2.GoogleOCIProvider:
+	case "gcp":
 		opts.GcpAutoLogin = true
 	}
 
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release.go
index c489cb6ca..37593c166 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release.go
@@ -12,9 +12,9 @@ import (
 	"time"
 
 	"github.com/bufbuild/connect-go"
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/common"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/pkg/connecterror"
@@ -40,7 +40,7 @@ var (
 )
 
 // namespace maybe "", in which case releases from all namespaces are returned
-func (s *Server) listReleasesInCluster(ctx context.Context, headers http.Header, namespace string) ([]helmv2beta2.HelmRelease, error) {
+func (s *Server) listReleasesInCluster(ctx context.Context, headers http.Header, namespace string) ([]helmv2.HelmRelease, error) {
 	client, err := s.getClient(headers, namespace)
 	if err != nil {
 		return nil, err
@@ -53,7 +53,7 @@ func (s *Server) listReleasesInCluster(ctx context.Context, headers http.Header,
 	// 2) there is a "consistent snapshot" problem, where the client doesn't want to
 	// see any results created/updated/deleted after the first request is issued
 	// To fix this, we must make use of resourceVersion := relList.GetResourceVersion()
-	var relList helmv2beta2.HelmReleaseList
+	var relList helmv2.HelmReleaseList
 	if err = client.List(ctx, &relList); err != nil {
 		return nil, connecterror.FromK8sError("list", "HelmRelease", namespace+"/*", err)
 	} else {
@@ -61,13 +61,13 @@ func (s *Server) listReleasesInCluster(ctx context.Context, headers http.Header,
 	}
 }
 
-func (s *Server) getReleaseInCluster(ctx context.Context, headers http.Header, key types.NamespacedName) (*helmv2beta2.HelmRelease, error) {
+func (s *Server) getReleaseInCluster(ctx context.Context, headers http.Header, key types.NamespacedName) (*helmv2.HelmRelease, error) {
 	client, err := s.getClient(headers, key.Namespace)
 	if err != nil {
 		return nil, err
 	}
 
-	var rel helmv2beta2.HelmRelease
+	var rel helmv2.HelmRelease
 	if err = client.Get(ctx, key, &rel); err != nil {
 		return nil, connecterror.FromK8sError("get", "HelmRelease", key.String(), err)
 	}
@@ -106,7 +106,7 @@ func (s *Server) paginatedInstalledPkgSummaries(ctx context.Context, headers htt
 	return installedPkgSummaries, nil
 }
 
-func (s *Server) installedPkgSummaryFromRelease(ctx context.Context, headers http.Header, rel helmv2beta2.HelmRelease) (*corev1.InstalledPackageSummary, error) {
+func (s *Server) installedPkgSummaryFromRelease(ctx context.Context, headers http.Header, rel helmv2.HelmRelease) (*corev1.InstalledPackageSummary, error) {
 	name, err := common.NamespacedName(&rel)
 	if err != nil {
 		return nil, err
@@ -236,11 +236,7 @@ func (s *Server) installedPackageDetail(ctx context.Context, headers http.Header
 
 	// this will only be present if install/upgrade succeeded
 	// TODO(agamez): flux upgrade - migrate to Status.History, see https://github.com/fluxcd/flux2/releases/tag/v2.2.0
-	pkgVersion := rel.Status.LastAppliedRevision
-	if pkgVersion == "" {
-		// this is the back-up option: will be there if the reconciliation is in progress or has failed
-		pkgVersion = rel.Status.LastAttemptedRevision
-	}
+	pkgVersion := rel.Status.LastAttemptedRevision
 
 	availablePackageRef, err := installedPackageAvailablePackageRef(rel)
 	if err != nil {
@@ -288,7 +284,7 @@ func (s *Server) installedPackageDetail(ctx context.Context, headers http.Header
 	}, nil
 }
 
-func (s *Server) getReleaseViaHelmApi(headers http.Header, key types.NamespacedName, rel *helmv2beta2.HelmRelease) (*release.Release, error) {
+func (s *Server) getReleaseViaHelmApi(headers http.Header, key types.NamespacedName, rel *helmv2.HelmRelease) (*release.Release, error) {
 	// post installation notes can only be retrieved via helm APIs, flux doesn't do it
 	// see discussion in https://cloud-native.slack.com/archives/CLAJ40HV3/p1629244025187100
 	if s.actionConfigGetter == nil {
@@ -458,7 +454,7 @@ func (s *Server) updateRelease(ctx context.Context, headers http.Header, package
 	// process and the current status no longer applies. metadata and spec I want
 	// to keep, as they may have had added labels and/or annotations and/or
 	// even other changes made by the user.
-	rel.Status = helmv2beta2.HelmReleaseStatus{}
+	rel.Status = helmv2.HelmReleaseStatus{}
 
 	client, err := s.getClient(headers, packageRef.Context.Namespace)
 	if err != nil {
@@ -489,7 +485,7 @@ func (s *Server) deleteRelease(ctx context.Context, headers http.Header, package
 
 	log.V(4).Infof("Deleting release: [%s]", packageRef.Identifier)
 
-	rel := &helmv2beta2.HelmRelease{
+	rel := &helmv2.HelmRelease{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      packageRef.Identifier,
 			Namespace: packageRef.Context.Namespace,
@@ -507,19 +503,19 @@ func (s *Server) deleteRelease(ctx context.Context, headers http.Header, package
 //  2. metadata.namespace, where this HelmRelease CRD will exist, same as (3) below
 //     per https://github.com/vmware-tanzu/kubeapps/pull/3640#issuecomment-949315105
 //  3. spec.targetNamespace, where flux will install any artifacts from the release
-func (s *Server) newFluxHelmRelease(chart *models.Chart, targetName types.NamespacedName, versionExpr string, reconcile *corev1.ReconciliationOptions, values map[string]interface{}) (*helmv2beta2.HelmRelease, error) {
-	fluxRelease := &helmv2beta2.HelmRelease{
+func (s *Server) newFluxHelmRelease(chart *models.Chart, targetName types.NamespacedName, versionExpr string, reconcile *corev1.ReconciliationOptions, values map[string]interface{}) (*helmv2.HelmRelease, error) {
+	fluxRelease := &helmv2.HelmRelease{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      targetName.Name,
 			Namespace: targetName.Namespace,
 		},
-		Spec: helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		Spec: helmv2.HelmReleaseSpec{
+			Chart: &helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart: chart.Name,
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
+					SourceRef: helmv2.CrossNamespaceObjectReference{
 						Name:      chart.Repo.Name,
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+						Kind:      sourcev1.HelmRepositoryKind,
 						Namespace: chart.Repo.Namespace,
 					},
 				},
@@ -581,7 +577,7 @@ func (s *Server) newFluxHelmRelease(chart *models.Chart, targetName types.Namesp
 //     when install completes with success
 //   - "reason" field: failure only when flux returns "InstallFailed" reason
 //     otherwise pending or unspecified when there are no status conditions to go by
-func isHelmReleaseReady(rel helmv2beta2.HelmRelease) (ready bool, status corev1.InstalledPackageStatus_StatusReason, userReason string) {
+func isHelmReleaseReady(rel helmv2.HelmRelease) (ready bool, status corev1.InstalledPackageStatus_StatusReason, userReason string) {
 	if !checkReleaseGeneration(rel) {
 		// according to https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
 		// observedGeneration represents the .metadata.generation that the condition was set based upon.
@@ -601,9 +597,8 @@ func isHelmReleaseReady(rel helmv2beta2.HelmRelease) (ready bool, status corev1.
 			//   "reason": "InstallFailed"
 			// i.e. not super useful
 			userReason = readyCond.Reason
-			if userReason == helmv2beta2.InstallFailedReason ||
-				userReason == helmv2beta2.UpgradeFailedReason ||
-				userReason == helmv2beta2.GetLastReleaseFailedReason {
+			if userReason == helmv2.InstallFailedReason ||
+				userReason == helmv2.UpgradeFailedReason {
 				isInstallFailed = true
 			}
 		}
@@ -627,7 +622,7 @@ func isHelmReleaseReady(rel helmv2beta2.HelmRelease) (ready bool, status corev1.
 	return false, corev1.InstalledPackageStatus_STATUS_REASON_PENDING, userReason
 }
 
-func installedPackageStatus(rel helmv2beta2.HelmRelease) *corev1.InstalledPackageStatus {
+func installedPackageStatus(rel helmv2.HelmRelease) *corev1.InstalledPackageStatus {
 	ready, reason, userReason := isHelmReleaseReady(rel)
 	return &corev1.InstalledPackageStatus{
 		Ready:      ready,
@@ -636,7 +631,7 @@ func installedPackageStatus(rel helmv2beta2.HelmRelease) *corev1.InstalledPackag
 	}
 }
 
-func installedPackageReconciliationOptions(rel *helmv2beta2.HelmRelease) *corev1.ReconciliationOptions {
+func installedPackageReconciliationOptions(rel *helmv2.HelmRelease) *corev1.ReconciliationOptions {
 	reconciliationOptions := &corev1.ReconciliationOptions{}
 	reconciliationOptions.Interval = pkgutils.FromDuration(&rel.Spec.Interval)
 	reconciliationOptions.Suspend = rel.Spec.Suspend
@@ -644,7 +639,7 @@ func installedPackageReconciliationOptions(rel *helmv2beta2.HelmRelease) *corev1
 	return reconciliationOptions
 }
 
-func installedPackageAvailablePackageRef(rel *helmv2beta2.HelmRelease) (*corev1.AvailablePackageReference, error) {
+func installedPackageAvailablePackageRef(rel *helmv2.HelmRelease) (*corev1.AvailablePackageReference, error) {
 	repoName := rel.Spec.Chart.Spec.SourceRef.Name
 	if repoName == "" {
 		return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("Missing required field spec.chart.spec.sourceRef.name"))
@@ -670,7 +665,7 @@ func installedPackageAvailablePackageRef(rel *helmv2beta2.HelmRelease) (*corev1.
 }
 
 // ref https://fluxcd.io/docs/components/helm/helmreleases/
-func helmReleaseName(key types.NamespacedName, rel *helmv2beta2.HelmRelease) types.NamespacedName {
+func helmReleaseName(key types.NamespacedName, rel *helmv2.HelmRelease) types.NamespacedName {
 	helmReleaseName := rel.Spec.ReleaseName
 	// according to docs ReleaseName is optional and defaults to a composition of
 	// '[TargetNamespace-]Name'.
@@ -691,7 +686,7 @@ func helmReleaseName(key types.NamespacedName, rel *helmv2beta2.HelmRelease) typ
 	return types.NamespacedName{Name: helmReleaseName, Namespace: helmReleaseNamespace}
 }
 
-func checkReleaseGeneration(rel helmv2beta2.HelmRelease) bool {
+func checkReleaseGeneration(rel helmv2.HelmRelease) bool {
 	generation := rel.GetGeneration()
 	observedGeneration := rel.Status.ObservedGeneration
 	return generation > 0 && generation == observedGeneration
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_integration_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_integration_test.go
index ba46e9633..dd5507e60 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_integration_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_integration_test.go
@@ -12,8 +12,8 @@ import (
 	"testing"
 	"time"
 
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/google/go-cmp/cmp"
 	"github.com/google/go-cmp/cmp/cmpopts"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
@@ -949,7 +949,7 @@ func TestKindClusterRBAC_ReadRelease(t *testing.T) {
 	rules := map[string][]rbacv1.PolicyRule{
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"get", "list"},
 			},
@@ -1044,14 +1044,14 @@ func TestKindClusterRBAC_ReadRelease(t *testing.T) {
 	nsToRules := map[string][]rbacv1.PolicyRule{
 		ns1: {
 			{
-				APIGroups: []string{sourcev1beta2.GroupVersion.Group},
+				APIGroups: []string{sourcev1.GroupVersion.Group},
 				Resources: []string{"helmcharts"},
 				Verbs:     []string{"get", "list"},
 			},
 		},
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"get", "list"},
 			},
@@ -1188,7 +1188,7 @@ func TestKindClusterRBAC_CreateRelease(t *testing.T) {
 	nsToRules := map[string][]rbacv1.PolicyRule{
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"create"},
 			},
@@ -1218,14 +1218,14 @@ func TestKindClusterRBAC_CreateRelease(t *testing.T) {
 	nsToRules = map[string][]rbacv1.PolicyRule{
 		ns1: {
 			{
-				APIGroups: []string{sourcev1beta2.GroupVersion.Group},
+				APIGroups: []string{sourcev1.GroupVersion.Group},
 				Resources: []string{"helmcharts"},
 				Verbs:     []string{"get"},
 			},
 		},
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"create"},
 			},
@@ -1335,7 +1335,7 @@ func TestKindClusterRBAC_UpdateRelease(t *testing.T) {
 	nsToRules := map[string][]rbacv1.PolicyRule{
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"get"},
 			},
@@ -1368,7 +1368,7 @@ func TestKindClusterRBAC_UpdateRelease(t *testing.T) {
 	nsToRules = map[string][]rbacv1.PolicyRule{
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"get", "update"},
 			},
@@ -1476,7 +1476,7 @@ func TestKindClusterRBAC_DeleteRelease(t *testing.T) {
 	nsToRules := map[string][]rbacv1.PolicyRule{
 		ns2: {
 			{
-				APIGroups: []string{helmv2beta2.GroupVersion.Group},
+				APIGroups: []string{helmv2.GroupVersion.Group},
 				Resources: []string{fluxHelmReleases},
 				Verbs:     []string{"delete"},
 			},
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_test.go
index 824afc678..8827ccdbe 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/release_test.go
@@ -12,10 +12,10 @@ import (
 	"time"
 
 	"github.com/bufbuild/connect-go"
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/google/go-cmp/cmp"
 	"github.com/google/go-cmp/cmp/cmpopts"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
@@ -43,7 +43,7 @@ type testSpecGetInstalledPackages struct {
 	releaseValues             *v1.JSON
 	releaseSuspend            bool
 	releaseServiceAccountName string
-	releaseStatus             helmv2beta2.HelmReleaseStatus
+	releaseStatus             helmv2.HelmReleaseStatus
 	// only used to test edge cases now, most tests should not set this
 	targetNamespace string
 }
@@ -511,7 +511,7 @@ func TestCreateInstalledPackage(t *testing.T) {
 		existingObjs            testSpecCreateInstalledPackage
 		expectedStatusCode      codes.Code
 		expectedResponse        *corev1.CreateInstalledPackageResponse
-		expectedRelease         *helmv2beta2.HelmRelease
+		expectedRelease         *helmv2.HelmRelease
 		defaultUpgradePolicyStr string
 	}{
 		{
@@ -637,7 +637,7 @@ func TestCreateInstalledPackage(t *testing.T) {
 			}
 			defer ts.Close()
 
-			s, mock, err := newSimpleServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo})
+			s, mock, err := newSimpleServerWithRepos(t, []sourcev1.HelmRepository{*repo})
 			if err != nil {
 				t.Fatal(err)
 			}
@@ -686,12 +686,12 @@ func TestCreateInstalledPackage(t *testing.T) {
 				t.Fatal(err)
 			} else {
 				key := types.NamespacedName{Namespace: tc.request.TargetContext.Namespace, Name: tc.request.Name}
-				var actualRel helmv2beta2.HelmRelease
+				var actualRel helmv2.HelmRelease
 				if err = ctrlClient.Get(context.Background(), key, &actualRel); err != nil {
 					t.Fatal(err)
 				} else {
 					// Values are JSON string and need to be compared as such
-					opts = cmpopts.IgnoreFields(helmv2beta2.HelmReleaseSpec{}, "Values")
+					opts = cmpopts.IgnoreFields(helmv2.HelmReleaseSpec{}, "Values")
 
 					// Manually setting TypeMeta, as the fakeclient doesn't do it anymore:
 					// https://github.com/kubernetes-sigs/controller-runtime/pull/2633
@@ -714,7 +714,7 @@ func TestUpdateInstalledPackage(t *testing.T) {
 		existingK8sObjs         *testSpecGetInstalledPackages
 		expectedErrorCode       connect.Code
 		expectedResponse        *corev1.UpdateInstalledPackageResponse
-		expectedRelease         *helmv2beta2.HelmRelease
+		expectedRelease         *helmv2.HelmRelease
 		defaultUpgradePolicyStr string
 	}{
 		{
@@ -894,7 +894,7 @@ func TestUpdateInstalledPackage(t *testing.T) {
 				Name:      tc.expectedResponse.InstalledPackageRef.Identifier,
 			}
 			ctx := context.Background()
-			var actualRel helmv2beta2.HelmRelease
+			var actualRel helmv2.HelmRelease
 			if ctrlClient, err := s.clientGetter.ControllerRuntime(http.Header{}, s.kubeappsCluster); err != nil {
 				t.Fatal(err)
 			} else if err = ctrlClient.Get(ctx, key, &actualRel); err != nil {
@@ -902,7 +902,7 @@ func TestUpdateInstalledPackage(t *testing.T) {
 			}
 
 			// Values are JSON string and need to be compared as such
-			opts = cmpopts.IgnoreFields(helmv2beta2.HelmReleaseSpec{}, "Values")
+			opts = cmpopts.IgnoreFields(helmv2.HelmReleaseSpec{}, "Values")
 
 			// Manually setting TypeMeta, as the fakeclient doesn't do it anymore:
 			// https://github.com/kubernetes-sigs/controller-runtime/pull/2633
@@ -985,7 +985,7 @@ func TestDeleteInstalledPackage(t *testing.T) {
 				Name:      tc.request.InstalledPackageRef.Identifier,
 			}
 			ctx := context.Background()
-			var actualRel helmv2beta2.HelmRelease
+			var actualRel helmv2.HelmRelease
 			if ctrlClient, err := s.clientGetter.ControllerRuntime(http.Header{}, s.kubeappsCluster); err != nil {
 				t.Fatal(err)
 			} else if err = ctrlClient.Get(ctx, key, &actualRel); !errors.IsNotFound(err) {
@@ -1129,15 +1129,15 @@ func TestGetInstalledPackageResourceRefs(t *testing.T) {
 	}
 }
 
-func newChartsAndReleases(t *testing.T, existingK8sObjs []testSpecGetInstalledPackages) (charts []sourcev1beta2.HelmChart, releases []helmv2beta2.HelmRelease, cleanup func()) {
+func newChartsAndReleases(t *testing.T, existingK8sObjs []testSpecGetInstalledPackages) (charts []sourcev1.HelmChart, releases []helmv2.HelmRelease, cleanup func()) {
 	httpServers := []*httptest.Server{}
 	cleanup = func() {
 		for _, ts := range httpServers {
 			ts.Close()
 		}
 	}
-	charts = []sourcev1beta2.HelmChart{}
-	releases = []helmv2beta2.HelmRelease{}
+	charts = []sourcev1.HelmChart{}
+	releases = []helmv2.HelmRelease{}
 
 	for _, existing := range existingK8sObjs {
 		tarGzBytes, err := os.ReadFile(existing.chartTarGz)
@@ -1155,24 +1155,24 @@ func newChartsAndReleases(t *testing.T, existingK8sObjs []testSpecGetInstalledPa
 		}))
 		httpServers = append(httpServers, ts)
 
-		chartSpec := &sourcev1beta2.HelmChartSpec{
+		chartSpec := &sourcev1.HelmChartSpec{
 			Chart: existing.chartName,
-			SourceRef: sourcev1beta2.LocalHelmChartSourceReference{
+			SourceRef: sourcev1.LocalHelmChartSourceReference{
 				Name: existing.repoName,
-				Kind: sourcev1beta2.HelmRepositoryKind,
+				Kind: sourcev1.HelmRepositoryKind,
 			},
 			Version:  existing.chartSpecVersion,
 			Interval: metav1.Duration{Duration: 1 * time.Minute},
 		}
 
-		chartStatus := &sourcev1beta2.HelmChartStatus{
+		chartStatus := &sourcev1.HelmChartStatus{
 			Conditions: []metav1.Condition{
 				{
 					LastTransitionTime: metav1.Time{Time: lastTransitionTime},
 					Message:            "Fetched revision: " + existing.chartSpecVersion,
 					Type:               fluxmeta.ReadyCondition,
 					Status:             metav1.ConditionTrue,
-					Reason:             sourcev1beta2.ChartPullSucceededReason,
+					Reason:             sourcev1.ChartPullSucceededReason,
 				},
 			},
 			Artifact: &sourcev1.Artifact{
@@ -1183,14 +1183,14 @@ func newChartsAndReleases(t *testing.T, existingK8sObjs []testSpecGetInstalledPa
 		chart := newChart(existing.chartName, existing.repoNamespace, chartSpec, chartStatus)
 		charts = append(charts, chart)
 
-		releaseSpec := &helmv2beta2.HelmReleaseSpec{
-			Chart: helmv2beta2.HelmChartTemplate{
-				Spec: helmv2beta2.HelmChartTemplateSpec{
+		releaseSpec := &helmv2.HelmReleaseSpec{
+			Chart: helmv2.HelmChartTemplate{
+				Spec: helmv2.HelmChartTemplateSpec{
 					Chart:   existing.chartName,
 					Version: existing.chartSpecVersion,
-					SourceRef: helmv2beta2.CrossNamespaceObjectReference{
+					SourceRef: helmv2.CrossNamespaceObjectReference{
 						Name:      existing.repoName,
-						Kind:      sourcev1beta2.HelmRepositoryKind,
+						Kind:      sourcev1.HelmRepositoryKind,
 						Namespace: existing.repoNamespace,
 					},
 				},
@@ -1217,8 +1217,8 @@ func newChartsAndReleases(t *testing.T, existingK8sObjs []testSpecGetInstalledPa
 	return charts, releases, cleanup
 }
 
-func newRelease(meta metav1.ObjectMeta, spec *helmv2beta2.HelmReleaseSpec, status *helmv2beta2.HelmReleaseStatus) helmv2beta2.HelmRelease {
-	helmRelease := helmv2beta2.HelmRelease{
+func newRelease(meta metav1.ObjectMeta, spec *helmv2.HelmReleaseSpec, status *helmv2.HelmReleaseStatus) helmv2.HelmRelease {
+	helmRelease := helmv2.HelmRelease{
 		ObjectMeta: meta,
 	}
 
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo.go
index 790b21514..5154ed7f7 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo.go
@@ -18,7 +18,7 @@ import (
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/pkg/k8sutils"
 
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/plugins/fluxv2/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/cache"
@@ -52,7 +52,7 @@ var (
 // returns a list of HelmRepositories from specified namespace.
 // ns can be "", in which case all namespaces (cluster-wide), excluding
 // the ones that the caller has no read access to
-func (s *Server) listReposInNamespace(ctx context.Context, headers http.Header, ns string) ([]sourcev1beta2.HelmRepository, error) {
+func (s *Server) listReposInNamespace(ctx context.Context, headers http.Header, ns string) ([]sourcev1.HelmRepository, error) {
 	// the actual List(...) call will be executed in the context of
 	// kubeapps-internal-kubeappsapis service account
 	// ref https://github.com/vmware-tanzu/kubeapps/issues/4390 for explanation
@@ -62,7 +62,7 @@ func (s *Server) listReposInNamespace(ctx context.Context, headers http.Header,
 		return nil, err
 	}
 
-	var repoList sourcev1beta2.HelmRepositoryList
+	var repoList sourcev1.HelmRepositoryList
 	listOptions := ctrlclient.ListOptions{
 		Namespace: ns,
 	}
@@ -83,7 +83,7 @@ func (s *Server) listReposInNamespace(ctx context.Context, headers http.Header,
 				return nil, err
 			}
 		}
-		items := []sourcev1beta2.HelmRepository{}
+		items := []sourcev1.HelmRepository{}
 		for _, item := range repoList.Items {
 			if allowedNamespaces.Has(item.GetNamespace()) {
 				items = append(items, item)
@@ -93,7 +93,7 @@ func (s *Server) listReposInNamespace(ctx context.Context, headers http.Header,
 	}
 }
 
-func (s *Server) getRepoInCluster(ctx context.Context, headers http.Header, key types.NamespacedName) (*sourcev1beta2.HelmRepository, error) {
+func (s *Server) getRepoInCluster(ctx context.Context, headers http.Header, key types.NamespacedName) (*sourcev1.HelmRepository, error) {
 	// unlike List(), there is no need to execute Get() in the context of
 	// kubeapps-internal-kubeappsapis service account and then filter out results based on
 	// whether or not the caller hasAccessToNamespace(). We can just pass the caller
@@ -103,7 +103,7 @@ func (s *Server) getRepoInCluster(ctx context.Context, headers http.Header, key
 	if err != nil {
 		return nil, err
 	}
-	var repo sourcev1beta2.HelmRepository
+	var repo sourcev1.HelmRepository
 	if err = client.Get(ctx, key, &repo); err != nil {
 		return nil, connecterror.FromK8sError("get", "HelmRepository", key.String(), err)
 	}
@@ -111,7 +111,7 @@ func (s *Server) getRepoInCluster(ctx context.Context, headers http.Header, key
 }
 
 // regexp expressions are used for matching actual names against expected patters
-func (s *Server) filterReadyReposByName(repoList []sourcev1beta2.HelmRepository, match []string) (sets.Set[string], error) {
+func (s *Server) filterReadyReposByName(repoList []sourcev1.HelmRepository, match []string) (sets.Set[string], error) {
 	if s.repoCache == nil {
 		return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("Server cache has not been properly initialized"))
 	}
@@ -232,7 +232,7 @@ func (s *Server) newRepo(ctx context.Context, request *connect.Request[corev1.Ad
 	}
 
 	typ := request.Msg.GetType()
-	if typ != "helm" && typ != sourcev1beta2.HelmRepositoryTypeOCI {
+	if typ != "helm" && typ != sourcev1.HelmRepositoryTypeOCI {
 		return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("Repository type [%s] not supported", typ))
 	}
 
@@ -323,7 +323,7 @@ func (s *Server) repoDetail(ctx context.Context, headers http.Header, repoRef *c
 	// will have a FluxPackageRepositoryCustomDetail in it. Flux spec already clearly states
 	// If you do not specify .spec.provider, it defaults to generic.
 	// https://fluxcd.io/flux/components/source/helmrepositories/#provider
-	if repo.Spec.Provider != "" && repo.Spec.Provider != sourcev1beta2.GenericOCIProvider {
+	if repo.Spec.Provider != "" && repo.Spec.Provider != "generic" {
 		if customDetail, err = anypb.New(&v1alpha1.FluxPackageRepositoryCustomDetail{
 			Provider: repo.Spec.Provider,
 		}); err != nil {
@@ -357,7 +357,7 @@ func (s *Server) repoDetail(ctx context.Context, headers http.Header, repoRef *c
 
 func (s *Server) repoSummaries(ctx context.Context, headers http.Header, ns string) ([]*corev1.PackageRepositorySummary, error) {
 	summaries := []*corev1.PackageRepositorySummary{}
-	var repos []sourcev1beta2.HelmRepository
+	var repos []sourcev1.HelmRepository
 	var err error
 	if ns == apiv1.NamespaceAll {
 		if repos, err = s.listReposInNamespace(ctx, headers, ns); err != nil {
@@ -368,7 +368,7 @@ func (s *Server) repoSummaries(ctx context.Context, headers http.Header, ns stri
 		// namely, if a specific namespace is passed in, we need to list repos in that namespace
 		// and if the caller happens not to have 'read' access to that namespace, a PermissionDenied
 		// error should be raised, as opposed to returning an empty list with no error
-		var repoList sourcev1beta2.HelmRepositoryList
+		var repoList sourcev1.HelmRepositoryList
 		var client ctrlclient.Client
 		if client, err = s.getClient(headers, ns); err != nil {
 			return nil, err
@@ -491,7 +491,7 @@ func (s *Server) updateRepo(ctx context.Context, repoRef *corev1.PackageReposito
 	// process and the current status no longer applies. metadata and spec I want
 	// to keep, as they may have had added labels and/or annotations and/or
 	// even other changes made by the user.
-	repo.Status = sourcev1beta2.HelmRepositoryStatus{}
+	repo.Status = sourcev1.HelmRepositoryStatus{}
 
 	if client, err := s.getClient(request.Header(), key.Namespace); err != nil {
 		return nil, err
@@ -529,7 +529,7 @@ func (s *Server) deleteRepo(ctx context.Context, headers http.Header, repoRef *c
 	// For kubeapps-managed secrets environment secrets will be deleted (garbage-collected)
 	// when the owner repo is deleted
 
-	repo := &sourcev1beta2.HelmRepository{
+	repo := &sourcev1.HelmRepository{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      repoRef.Identifier,
 			Namespace: repoRef.Context.Namespace,
@@ -562,10 +562,10 @@ func (s *repoEventSink) onAddRepo(key string, obj ctrlclient.Object) (interface{
 	log.V(4).Infof("+onAddRepo(%s)", key)
 	defer log.V(4).Info("-onAddRepo()")
 
-	if repo, ok := obj.(*sourcev1beta2.HelmRepository); !ok {
-		return nil, false, fmt.Errorf("expected an instance of *sourcev1beta2.HelmRepository, got: %T", obj)
+	if repo, ok := obj.(*sourcev1.HelmRepository); !ok {
+		return nil, false, fmt.Errorf("expected an instance of *sourcev1.HelmRepository, got: %T", obj)
 	} else if isRepoReady(*repo) {
-		if repo.Spec.Type == sourcev1beta2.HelmRepositoryTypeOCI {
+		if repo.Spec.Type == sourcev1.HelmRepositoryTypeOCI {
 			return s.onAddOciRepo(*repo)
 		} else {
 			return s.onAddHttpRepo(*repo)
@@ -579,7 +579,7 @@ func (s *repoEventSink) onAddRepo(key string, obj ctrlclient.Object) (interface{
 }
 
 // ref https://fluxcd.io/docs/components/source/helmrepositories/#status
-func (s *repoEventSink) onAddHttpRepo(repo sourcev1beta2.HelmRepository) ([]byte, bool, error) {
+func (s *repoEventSink) onAddHttpRepo(repo sourcev1.HelmRepository) ([]byte, bool, error) {
 	if artifact := repo.GetArtifact(); artifact != nil {
 		if checksum := artifact.Digest; checksum == "" {
 			return nil, false, connect.NewError(connect.CodeInternal,
@@ -595,7 +595,7 @@ func (s *repoEventSink) onAddHttpRepo(repo sourcev1beta2.HelmRepository) ([]byte
 	}
 }
 
-func (s *repoEventSink) indexAndEncode(checksum string, repo sourcev1beta2.HelmRepository) ([]byte, bool, error) {
+func (s *repoEventSink) indexAndEncode(checksum string, repo sourcev1.HelmRepository) ([]byte, bool, error) {
 	charts, err := s.indexOneRepo(repo)
 	if err != nil {
 		return nil, false, err
@@ -637,7 +637,7 @@ func (s *repoEventSink) indexAndEncode(checksum string, repo sourcev1beta2.HelmR
 
 // it is assumed the caller has already checked that this repo is ready
 // At present, there is only one caller of indexOneRepo() and this check is already done by it
-func (s *repoEventSink) indexOneRepo(repo sourcev1beta2.HelmRepository) ([]models.Chart, error) {
+func (s *repoEventSink) indexOneRepo(repo sourcev1.HelmRepository) ([]models.Chart, error) {
 	startTime := time.Now()
 
 	// ref https://fluxcd.io/docs/components/source/helmrepositories/#status
@@ -698,12 +698,12 @@ func (s *repoEventSink) indexOneRepo(repo sourcev1beta2.HelmRepository) ([]model
 
 // onModifyRepo essentially tells the cache whether or not to and what to store for a given key
 func (s *repoEventSink) onModifyRepo(key string, obj ctrlclient.Object, oldValue interface{}) (interface{}, bool, error) {
-	if repo, ok := obj.(*sourcev1beta2.HelmRepository); !ok {
-		return nil, false, fmt.Errorf("expected an instance of *sourcev1beta2.HelmRepository, got: %T", obj)
+	if repo, ok := obj.(*sourcev1.HelmRepository); !ok {
+		return nil, false, fmt.Errorf("expected an instance of *sourcev1.HelmRepository, got: %T", obj)
 	} else if isRepoReady(*repo) {
 		// first check the repo is ready
 
-		if repo.Spec.Type == sourcev1beta2.HelmRepositoryTypeOCI {
+		if repo.Spec.Type == sourcev1.HelmRepositoryTypeOCI {
 			return s.onModifyOciRepo(key, oldValue, *repo)
 		} else {
 			return s.onModifyHttpRepo(key, oldValue, *repo)
@@ -716,7 +716,7 @@ func (s *repoEventSink) onModifyRepo(key string, obj ctrlclient.Object, oldValue
 	}
 }
 
-func (s *repoEventSink) onModifyHttpRepo(key string, oldValue interface{}, repo sourcev1beta2.HelmRepository) ([]byte, bool, error) {
+func (s *repoEventSink) onModifyHttpRepo(key string, oldValue interface{}, repo sourcev1.HelmRepository) ([]byte, bool, error) {
 	// We should to compare checksums on what's stored in the cache
 	// vs the modified object to see if the contents has really changed before embarking on
 	// expensive operation indexOneRepo() below.
@@ -796,7 +796,7 @@ func (s *repoEventSink) fromKey(key string) (*types.NamespacedName, error) {
 	return &types.NamespacedName{Namespace: parts[1], Name: parts[2]}, nil
 }
 
-func (s *repoEventSink) getRepoSecret(ctx context.Context, repo sourcev1beta2.HelmRepository) (*apiv1.Secret, error) {
+func (s *repoEventSink) getRepoSecret(ctx context.Context, repo sourcev1.HelmRepository) (*apiv1.Secret, error) {
 	if repo.Spec.SecretRef == nil {
 		return nil, nil
 	}
@@ -825,7 +825,7 @@ func (s *repoEventSink) getRepoSecret(ctx context.Context, repo sourcev1beta2.He
 
 // The reason I do this here is to set up auth that may be needed to fetch chart tarballs by
 // ChartCache
-func (s *repoEventSink) clientOptionsForHttpRepo(ctx context.Context, repo sourcev1beta2.HelmRepository) (*common.HttpClientOptions, error) {
+func (s *repoEventSink) clientOptionsForHttpRepo(ctx context.Context, repo sourcev1.HelmRepository) (*common.HttpClientOptions, error) {
 	if secret, err := s.getRepoSecret(ctx, repo); err == nil && secret != nil {
 		return common.HttpClientOptionsFromSecret(*secret)
 	} else {
@@ -837,7 +837,7 @@ func (s *repoEventSink) clientOptionsForHttpRepo(ctx context.Context, repo sourc
 // repo-related utilities
 //
 
-func isRepoReady(repo sourcev1beta2.HelmRepository) bool {
+func isRepoReady(repo sourcev1.HelmRepository) bool {
 	// see docs at https://fluxcd.io/docs/components/source/helmrepositories/
 	// Confirm the state we are observing is for the current generation
 	if !checkRepoGeneration(repo) {
@@ -854,7 +854,7 @@ func isRepoReady(repo sourcev1beta2.HelmRepository) bool {
 // - reason: if present
 // docs:
 // 1. https://fluxcd.io/docs/components/source/helmrepositories/#status-examples
-func isHelmRepositoryReady(repo sourcev1beta2.HelmRepository) (complete bool, success bool, reason string) {
+func isHelmRepositoryReady(repo sourcev1.HelmRepository) (complete bool, success bool, reason string) {
 	// flux source-controller v1beta2 API made a change so that we can no longer
 	// rely on a simple "metadata.generation" vs "status.observedGeneration" check for a
 	// quick answer. The resource may now exist with "observedGeneration": -1 either in
@@ -882,7 +882,7 @@ func isHelmRepositoryReady(repo sourcev1beta2.HelmRepository) (complete bool, su
 	return false, false, reason
 }
 
-func repoStatus(repo sourcev1beta2.HelmRepository) *corev1.PackageRepositoryStatus {
+func repoStatus(repo sourcev1.HelmRepository) *corev1.PackageRepositoryStatus {
 	complete, success, reason := isHelmRepositoryReady(repo)
 	s := &corev1.PackageRepositoryStatus{
 		Ready:      complete && success,
@@ -899,7 +899,7 @@ func repoStatus(repo sourcev1beta2.HelmRepository) *corev1.PackageRepositoryStat
 	return s
 }
 
-func checkRepoGeneration(repo sourcev1beta2.HelmRepository) bool {
+func checkRepoGeneration(repo sourcev1.HelmRepository) bool {
 	generation := repo.GetGeneration()
 	observedGeneration := repo.Status.ObservedGeneration
 	return generation > 0 && generation == observedGeneration
@@ -914,7 +914,7 @@ func newFluxHelmRepo(
 	interval string,
 	secret *apiv1.Secret,
 	passCredentials bool,
-	provider string) (*sourcev1beta2.HelmRepository, error) {
+	provider string) (*sourcev1.HelmRepository, error) {
 	pollInterval := defaultPollInterval
 	if interval != "" {
 		if duration, err := pkgutils.ToDuration(interval); err != nil {
@@ -923,18 +923,18 @@ func newFluxHelmRepo(
 			pollInterval = *duration
 		}
 	}
-	fluxRepo := &sourcev1beta2.HelmRepository{
+	fluxRepo := &sourcev1.HelmRepository{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      targetName.Name,
 			Namespace: targetName.Namespace,
 		},
-		Spec: sourcev1beta2.HelmRepositorySpec{
+		Spec: sourcev1.HelmRepositorySpec{
 			URL:      url,
 			Interval: pollInterval,
 		},
 	}
-	if typ == sourcev1beta2.HelmRepositoryTypeOCI {
-		fluxRepo.Spec.Type = sourcev1beta2.HelmRepositoryTypeOCI
+	if typ == sourcev1.HelmRepositoryTypeOCI {
+		fluxRepo.Spec.Type = sourcev1.HelmRepositoryTypeOCI
 	}
 	if desc != "" {
 		k8sutils.SetDescription(&fluxRepo.ObjectMeta, desc)
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_auth.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_auth.go
index 517a503ec..f811e0297 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_auth.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_auth.go
@@ -10,7 +10,7 @@ import (
 	"net/http"
 
 	"github.com/bufbuild/connect-go"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/pkg/connecterror"
 	"github.com/vmware-tanzu/kubeapps/pkg/kube"
@@ -79,7 +79,7 @@ func (s *Server) handleRepoSecretForCreate(
 func (s *Server) handleRepoSecretForUpdate(
 	ctx context.Context,
 	headers http.Header,
-	repo *sourcev1beta2.HelmRepository,
+	repo *sourcev1.HelmRepository,
 	newTlsConfig *corev1.PackageRepositoryTlsConfig,
 	newAuth *corev1.PackageRepositoryAuth) (updatedSecret *apiv1.Secret, isKubeappsManagedSecret bool, isSecretUpdated bool, err error) {
 
@@ -208,7 +208,7 @@ func (s *Server) validateUserManagedRepoSecret(
 						return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("Specified secret [%s] missing fields 'username' and/or 'password'", secretRef))
 					}
 				case corev1.PackageRepositoryAuth_PACKAGE_REPOSITORY_AUTH_TYPE_TLS:
-					if repoType == sourcev1beta2.HelmRepositoryTypeOCI {
+					if repoType == sourcev1.HelmRepositoryTypeOCI {
 						// ref https://fluxcd.io/flux/components/source/helmrepositories/#tls-authentication
 						// Note: TLS authentication is not yet supported by OCI Helm repositories.
 						return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("Package repository authentication type %q is not supported for OCI repositories", auth.Type))
@@ -218,7 +218,7 @@ func (s *Server) validateUserManagedRepoSecret(
 						}
 					}
 				case corev1.PackageRepositoryAuth_PACKAGE_REPOSITORY_AUTH_TYPE_DOCKER_CONFIG_JSON:
-					if repoType == sourcev1beta2.HelmRepositoryTypeOCI {
+					if repoType == sourcev1.HelmRepositoryTypeOCI {
 						if secret.Data[apiv1.DockerConfigJsonKey] == nil {
 							return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("Specified secret [%s] missing field '%s'", secretRef, apiv1.DockerConfigJsonKey))
 						}
@@ -251,7 +251,7 @@ func (s *Server) setOwnerReferencesForRepoSecret(
 	ctx context.Context,
 	headers http.Header,
 	secret *apiv1.Secret,
-	repo *sourcev1beta2.HelmRepository) error {
+	repo *sourcev1.HelmRepository) error {
 
 	// TODO(agamez): flux upgrade - migrate to CertSecretRef, see https://github.com/fluxcd/flux2/releases/tag/v2.1.0
 	if repo.Spec.SecretRef != nil && secret != nil {
@@ -263,9 +263,9 @@ func (s *Server) setOwnerReferencesForRepoSecret(
 				*metav1.NewControllerRef(
 					repo,
 					schema.GroupVersionKind{
-						Group:   sourcev1beta2.GroupVersion.Group,
-						Version: sourcev1beta2.GroupVersion.Version,
-						Kind:    sourcev1beta2.HelmRepositoryKind,
+						Group:   sourcev1.GroupVersion.Group,
+						Version: sourcev1.GroupVersion.Version,
+						Kind:    sourcev1.HelmRepositoryKind,
 					}),
 			}
 			if _, err := secretsInterface.Update(ctx, secret, metav1.UpdateOptions{}); err != nil {
@@ -276,7 +276,7 @@ func (s *Server) setOwnerReferencesForRepoSecret(
 	return nil
 }
 
-func (s *Server) getRepoTlsConfigAndAuth(ctx context.Context, headers http.Header, repo sourcev1beta2.HelmRepository) (*corev1.PackageRepositoryTlsConfig, *corev1.PackageRepositoryAuth, error) {
+func (s *Server) getRepoTlsConfigAndAuth(ctx context.Context, headers http.Header, repo sourcev1.HelmRepository) (*corev1.PackageRepositoryTlsConfig, *corev1.PackageRepositoryAuth, error) {
 	var tlsConfig *corev1.PackageRepositoryTlsConfig
 	var auth *corev1.PackageRepositoryAuth
 
@@ -385,7 +385,7 @@ func newSecretFromTlsConfigAndAuth(repoName types.NamespacedName,
 				}
 			}
 		case corev1.PackageRepositoryAuth_PACKAGE_REPOSITORY_AUTH_TYPE_TLS:
-			if repoType == sourcev1beta2.HelmRepositoryTypeOCI {
+			if repoType == sourcev1.HelmRepositoryTypeOCI {
 				// ref https://fluxcd.io/flux/components/source/helmrepositories/#tls-authentication
 				// Note: TLS authentication is not yet supported by OCI Helm repositories.
 				return nil, false, connect.NewError(connect.CodeInternal, fmt.Errorf("Package repository authentication type %q is not supported for OCI repositories", auth.Type))
@@ -413,7 +413,7 @@ func newSecretFromTlsConfigAndAuth(repoName types.NamespacedName,
 				}
 			}
 		case corev1.PackageRepositoryAuth_PACKAGE_REPOSITORY_AUTH_TYPE_DOCKER_CONFIG_JSON:
-			if repoType != sourcev1beta2.HelmRepositoryTypeOCI {
+			if repoType != sourcev1.HelmRepositoryTypeOCI {
 				return nil, false, connect.NewError(connect.CodeInternal, fmt.Errorf("Unsupported package repository authentication type: %q", auth.Type))
 			}
 
@@ -569,7 +569,7 @@ func getRepoTlsConfigAndAuthWithKubeappsManagedSecrets(secret *apiv1.Secret) (*c
 	return tlsConfig, auth, nil
 }
 
-func isSecretKubeappsManaged(secret *apiv1.Secret, repo *sourcev1beta2.HelmRepository) bool {
+func isSecretKubeappsManaged(secret *apiv1.Secret, repo *sourcev1.HelmRepository) bool {
 	if !metav1.IsControlledBy(secret, repo) {
 		return false
 	}
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_test.go
index e90758d47..23d9e3e68 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/repo_test.go
@@ -19,7 +19,7 @@ import (
 	"github.com/bufbuild/connect-go"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/go-redis/redismock/v8"
 	"github.com/google/go-cmp/cmp"
 	"github.com/google/go-cmp/cmp/cmpopts"
@@ -414,7 +414,7 @@ func TestGetAvailablePackageSummariesWithoutPagination(t *testing.T) {
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			repos := []sourcev1beta2.HelmRepository{}
+			repos := []sourcev1.HelmRepository{}
 
 			for _, rs := range tc.repos {
 				ts2, repo, err := newHttpRepoAndServeIndex(rs.index, rs.name, rs.namespace, nil, "")
@@ -479,7 +479,7 @@ func TestGetAvailablePackageSummariesWithPagination(t *testing.T) {
 				index:     testYaml("index-with-categories.yaml"),
 			},
 		}
-		repos := []sourcev1beta2.HelmRepository{}
+		repos := []sourcev1.HelmRepository{}
 		for _, rs := range existingRepos {
 			ts2, repo, err := newHttpRepoAndServeIndex(rs.index, rs.name, rs.namespace, nil, "")
 			if err != nil {
@@ -616,12 +616,12 @@ func TestGetAvailablePackageSummaryAfterRepoIndexUpdate(t *testing.T) {
 		}))
 		defer ts.Close()
 
-		repoSpec := &sourcev1beta2.HelmRepositorySpec{
+		repoSpec := &sourcev1.HelmRepositorySpec{
 			URL:      "https://example.repo.com/charts",
 			Interval: metav1.Duration{Duration: 1 * time.Minute},
 		}
 
-		repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+		repoStatus := &sourcev1.HelmRepositoryStatus{
 			Artifact: &sourcev1.Artifact{
 				Digest:         "651f952130ea96823711d08345b85e82be011dc6",
 				LastUpdateTime: metav1.Time{Time: lastUpdateTime},
@@ -640,7 +640,7 @@ func TestGetAvailablePackageSummaryAfterRepoIndexUpdate(t *testing.T) {
 		repoName := types.NamespacedName{Namespace: "ns2", Name: "testrepo"}
 		repo := newRepo(repoName.Name, repoName.Namespace, repoSpec, repoStatus)
 
-		s, mock, err := newSimpleServerWithRepos(t, []sourcev1beta2.HelmRepository{repo})
+		s, mock, err := newSimpleServerWithRepos(t, []sourcev1.HelmRepository{repo})
 		if err != nil {
 			t.Fatalf("error instantiating the server: %v", err)
 		}
@@ -752,7 +752,7 @@ func TestGetAvailablePackageSummaryAfterFluxHelmRepoDelete(t *testing.T) {
 		}
 		defer ts.Close()
 
-		s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, charts, nil)
+		s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, charts, nil)
 		if err != nil {
 			t.Fatalf("%+v", err)
 		}
@@ -847,7 +847,7 @@ func TestGetAvailablePackageSummaryAfterCacheResync(t *testing.T) {
 		}
 		defer ts2.Close()
 
-		s, mock, err := newSimpleServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo})
+		s, mock, err := newSimpleServerWithRepos(t, []sourcev1.HelmRepository{*repo})
 		if err != nil {
 			t.Fatalf("error instantiating the server: %v", err)
 		}
@@ -932,7 +932,7 @@ func TestGetAvailablePackageSummariesAfterCacheResyncQueueNotIdle(t *testing.T)
 		}
 
 		// first, I'd like to fill up the work queue with a whole bunch of work items
-		repos := []*sourcev1beta2.HelmRepository{}
+		repos := []*sourcev1.HelmRepository{}
 		mapReposCached := make(map[string][]byte)
 		keysInOrder := []string{}
 
@@ -1181,7 +1181,7 @@ func TestAddPackageRepository(t *testing.T) {
 		name                  string
 		request               *corev1.AddPackageRepositoryRequest
 		expectedResponse      *corev1.AddPackageRepositoryResponse
-		expectedRepo          *sourcev1beta2.HelmRepository
+		expectedRepo          *sourcev1.HelmRepository
 		errorCode             connect.Code
 		existingSecret        *apiv1.Secret
 		expectedCreatedSecret *apiv1.Secret
@@ -1411,7 +1411,7 @@ func TestAddPackageRepository(t *testing.T) {
 			if ctrlClient, err := s.clientGetter.ControllerRuntime(http.Header{}, s.kubeappsCluster); err != nil {
 				t.Fatal(err)
 			} else {
-				var actualRepo sourcev1beta2.HelmRepository
+				var actualRepo sourcev1.HelmRepository
 				if err = ctrlClient.Get(ctx, nsname, &actualRepo); err != nil {
 					t.Fatal(err)
 				} else {
@@ -1429,7 +1429,7 @@ func TestAddPackageRepository(t *testing.T) {
 						}
 					} else {
 						// TODO(agamez): flux upgrade - migrate to CertSecretRef, see https://github.com/fluxcd/flux2/releases/tag/v2.1.0
-						opt1 := cmpopts.IgnoreFields(sourcev1beta2.HelmRepositorySpec{}, "SecretRef")
+						opt1 := cmpopts.IgnoreFields(sourcev1.HelmRepositorySpec{}, "SecretRef")
 
 						// Manually setting TypeMeta, as the fakeclient doesn't do it anymore:
 						// https://github.com/kubernetes-sigs/controller-runtime/pull/2633
@@ -1637,7 +1637,7 @@ func TestGetPackageRepositoryDetail(t *testing.T) {
 				secretRef = tc.repoSecret.Name
 				secrets = append(secrets, tc.repoSecret)
 			}
-			var repo *sourcev1beta2.HelmRepository
+			var repo *sourcev1.HelmRepository
 			if !tc.pending && !tc.failed {
 				var ts *httptest.Server
 				var err error
@@ -1647,11 +1647,11 @@ func TestGetPackageRepositoryDetail(t *testing.T) {
 				}
 				defer ts.Close()
 			} else if tc.pending {
-				repoSpec := &sourcev1beta2.HelmRepositorySpec{
+				repoSpec := &sourcev1.HelmRepositorySpec{
 					URL:      "https://example.repo.com/charts",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				}
-				repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+				repoStatus := &sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -1665,11 +1665,11 @@ func TestGetPackageRepositoryDetail(t *testing.T) {
 				repo1 := newRepo(tc.repoName, tc.repoNamespace, repoSpec, repoStatus)
 				repo = &repo1
 			} else { // failed
-				repoSpec := &sourcev1beta2.HelmRepositorySpec{
+				repoSpec := &sourcev1.HelmRepositorySpec{
 					URL:      "https://example.repo.com/charts",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				}
-				repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+				repoStatus := &sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -1686,7 +1686,7 @@ func TestGetPackageRepositoryDetail(t *testing.T) {
 
 			// the index.yaml will contain links to charts but for the purposes
 			// of this test they do not matter
-			s, _, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, nil, secrets)
+			s, _, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, nil, secrets)
 			if err != nil {
 				t.Fatalf("error instantiating the server: %v", err)
 			}
@@ -1744,7 +1744,7 @@ func TestGetOciPackageRepositoryDetail(t *testing.T) {
 				t.Fatal(err)
 			}
 
-			s, mock, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, nil, nil)
+			s, mock, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, nil, nil)
 			if err != nil {
 				t.Fatalf("error instantiating the server: %v", err)
 			}
@@ -1786,7 +1786,7 @@ func TestGetPackageRepositorySummaries(t *testing.T) {
 	testCases := []struct {
 		name              string
 		request           *corev1.GetPackageRepositorySummariesRequest
-		existingRepos     []sourcev1beta2.HelmRepository
+		existingRepos     []sourcev1.HelmRepository
 		expectedErrorCode connect.Code
 		expectedResponse  *corev1.GetPackageRepositorySummariesResponse
 	}{
@@ -1795,7 +1795,7 @@ func TestGetPackageRepositorySummaries(t *testing.T) {
 			request: &corev1.GetPackageRepositorySummariesRequest{
 				Context: &corev1.Context{},
 			},
-			existingRepos: []sourcev1beta2.HelmRepository{
+			existingRepos: []sourcev1.HelmRepository{
 				get_summaries_repo_1,
 				get_summaries_repo_2,
 				get_summaries_repo_3,
@@ -1815,7 +1815,7 @@ func TestGetPackageRepositorySummaries(t *testing.T) {
 			request: &corev1.GetPackageRepositorySummariesRequest{
 				Context: &corev1.Context{Namespace: "foo"},
 			},
-			existingRepos: []sourcev1beta2.HelmRepository{
+			existingRepos: []sourcev1.HelmRepository{
 				get_summaries_repo_1,
 				get_summaries_repo_2,
 				get_summaries_repo_3,
@@ -2124,7 +2124,7 @@ func TestUpdatePackageRepository(t *testing.T) {
 			if tc.newRepoSecret != nil {
 				secrets = append(secrets, tc.newRepoSecret)
 			}
-			var repo *sourcev1beta2.HelmRepository
+			var repo *sourcev1.HelmRepository
 			if !tc.pending {
 				var ts *httptest.Server
 				var err error
@@ -2134,11 +2134,11 @@ func TestUpdatePackageRepository(t *testing.T) {
 				}
 				defer ts.Close()
 			} else {
-				repoSpec := &sourcev1beta2.HelmRepositorySpec{
+				repoSpec := &sourcev1.HelmRepositorySpec{
 					URL:      "https://example.repo.com/charts",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				}
-				repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+				repoStatus := &sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2156,7 +2156,7 @@ func TestUpdatePackageRepository(t *testing.T) {
 
 			// the index.yaml will contain links to charts but for the purposes
 			// of this test they do not matter
-			s, _, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, nil, secrets)
+			s, _, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, nil, secrets)
 			if err != nil {
 				t.Fatalf("error instantiating the server: %v", err)
 			}
@@ -2219,7 +2219,7 @@ func TestUpdatePackageRepository(t *testing.T) {
 
 				// check the created/updated secret
 				if tc.expectedCreatedSecret != nil {
-					var actualRepo sourcev1beta2.HelmRepository
+					var actualRepo sourcev1.HelmRepository
 					if err = ctrlClient.Get(ctx, types.NamespacedName{Namespace: tc.repoNamespace, Name: tc.repoName}, &actualRepo); err != nil {
 						t.Fatal(err)
 					}
@@ -2285,7 +2285,7 @@ func TestDeletePackageRepository(t *testing.T) {
 			if tc.newRepoSecret != nil {
 				secrets = append(secrets, tc.newRepoSecret)
 			}
-			var repo *sourcev1beta2.HelmRepository
+			var repo *sourcev1.HelmRepository
 			if !tc.pending {
 				var ts *httptest.Server
 				var err error
@@ -2295,11 +2295,11 @@ func TestDeletePackageRepository(t *testing.T) {
 				}
 				defer ts.Close()
 			} else {
-				repoSpec := &sourcev1beta2.HelmRepositorySpec{
+				repoSpec := &sourcev1.HelmRepositorySpec{
 					URL:      "https://example.repo.com/charts",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				}
-				repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+				repoStatus := &sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							LastTransitionTime: metav1.Time{Time: lastTransitionTime},
@@ -2317,7 +2317,7 @@ func TestDeletePackageRepository(t *testing.T) {
 
 			// the index.yaml will contain links to charts but for the purposes
 			// of this test they do not matter
-			s, _, err := newServerWithRepos(t, []sourcev1beta2.HelmRepository{*repo}, nil, secrets)
+			s, _, err := newServerWithRepos(t, []sourcev1.HelmRepository{*repo}, nil, secrets)
 			if err != nil {
 				t.Fatalf("error instantiating the server: %v", err)
 			}
@@ -2331,7 +2331,7 @@ func TestDeletePackageRepository(t *testing.T) {
 				Namespace: tc.request.PackageRepoRef.Context.Namespace,
 				Name:      tc.request.PackageRepoRef.Identifier,
 			}
-			var actualRepo sourcev1beta2.HelmRepository
+			var actualRepo sourcev1.HelmRepository
 			if tc.expectedErrorCode == 0 {
 				if err = ctrlClient.Get(ctx, nsname, &actualRepo); err != nil {
 					t.Fatal(err)
@@ -2414,7 +2414,7 @@ func TestGetOciAvailablePackageSummariesWithoutPagination(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			initOciFakeClientBuilder(t, *tc.seedData)
 
-			repos := []sourcev1beta2.HelmRepository{}
+			repos := []sourcev1.HelmRepository{}
 
 			for _, rs := range tc.repos {
 				repo, err := newOciRepo(rs.repoName, rs.repoNamespace, rs.repoUrl)
@@ -2451,8 +2451,8 @@ func TestGetOciAvailablePackageSummariesWithoutPagination(t *testing.T) {
 	}
 }
 
-func newRepo(name string, namespace string, spec *sourcev1beta2.HelmRepositorySpec, status *sourcev1beta2.HelmRepositoryStatus) sourcev1beta2.HelmRepository {
-	helmRepository := sourcev1beta2.HelmRepository{
+func newRepo(name string, namespace string, spec *sourcev1.HelmRepositorySpec, status *sourcev1.HelmRepositoryStatus) sourcev1.HelmRepository {
+	helmRepository := sourcev1.HelmRepository{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:       name,
 			Generation: 1,
@@ -2489,7 +2489,7 @@ func newRepo(name string, namespace string, spec *sourcev1beta2.HelmRepositorySp
 
 // these functions should affect only unit test, not production code
 // does a series of mock.ExpectGet(...)
-func (s *Server) redisMockExpectGetFromRepoCache(mock redismock.ClientMock, filterOptions *corev1.FilterOptions, repos ...sourcev1beta2.HelmRepository) error {
+func (s *Server) redisMockExpectGetFromRepoCache(mock redismock.ClientMock, filterOptions *corev1.FilterOptions, repos ...sourcev1.HelmRepository) error {
 	mapVals := make(map[string][]byte)
 	ociRepoKeys := sets.Set[string]{}
 	for _, r := range repos {
@@ -2532,7 +2532,7 @@ func (s *Server) redisMockExpectGetFromRepoCache(mock redismock.ClientMock, filt
 	return nil
 }
 
-func (s *Server) redisMockSetValueForRepo(mock redismock.ClientMock, repo sourcev1beta2.HelmRepository, oldValue []byte) (key string, bytes []byte, err error) {
+func (s *Server) redisMockSetValueForRepo(mock redismock.ClientMock, repo sourcev1.HelmRepository, oldValue []byte) (key string, bytes []byte, err error) {
 	bg := &clientgetter.FixedClusterClientProvider{ClientsFunc: func(ctx context.Context) (*clientgetter.ClientGetter, error) {
 		return s.clientGetter.GetClients(http.Header{}, s.kubeappsCluster)
 	}}
@@ -2540,7 +2540,7 @@ func (s *Server) redisMockSetValueForRepo(mock redismock.ClientMock, repo source
 	return sinkNoCache.redisMockSetValueForRepo(mock, repo, oldValue)
 }
 
-func (sink *repoEventSink) redisMockSetValueForRepo(mock redismock.ClientMock, repo sourcev1beta2.HelmRepository, oldValue []byte) (key string, newValue []byte, err error) {
+func (sink *repoEventSink) redisMockSetValueForRepo(mock redismock.ClientMock, repo sourcev1.HelmRepository, oldValue []byte) (key string, newValue []byte, err error) {
 	if key, newValue, err = sink.redisKeyValueForRepo(repo); err != nil {
 		if oldValue == nil {
 			mock.ExpectGet(key).RedisNil()
@@ -2565,7 +2565,7 @@ func redisMockSetValueForRepo(mock redismock.ClientMock, key string, newValue, o
 	mock.ExpectInfo("memory").SetVal("used_memory_rss_human:NA\r\nmaxmemory_human:NA")
 }
 
-func (s *Server) redisKeyValueForRepo(r sourcev1beta2.HelmRepository) (key string, byteArray []byte, err error) {
+func (s *Server) redisKeyValueForRepo(r sourcev1.HelmRepository) (key string, byteArray []byte, err error) {
 	cg := &clientgetter.FixedClusterClientProvider{ClientsFunc: func(ctx context.Context) (*clientgetter.ClientGetter, error) {
 		return s.clientGetter.GetClients(http.Header{}, s.kubeappsCluster)
 	}}
@@ -2573,7 +2573,7 @@ func (s *Server) redisKeyValueForRepo(r sourcev1beta2.HelmRepository) (key strin
 	return sinkNoChartCache.redisKeyValueForRepo(r)
 }
 
-func (sink *repoEventSink) redisKeyValueForRepo(r sourcev1beta2.HelmRepository) (key string, byteArray []byte, err error) {
+func (sink *repoEventSink) redisKeyValueForRepo(r sourcev1.HelmRepository) (key string, byteArray []byte, err error) {
 	if key, err = redisKeyForRepo(r); err != nil {
 		return key, nil, err
 	} else {
@@ -2591,7 +2591,7 @@ func (sink *repoEventSink) redisKeyValueForRepo(r sourcev1beta2.HelmRepository)
 	}
 }
 
-func redisKeyForRepo(r sourcev1beta2.HelmRepository) (string, error) {
+func redisKeyForRepo(r sourcev1.HelmRepository) (string, error) {
 	// redis convention on key format
 	// https://redis.io/topics/data-types-intro
 	// Try to stick with a schema. For instance "object-type:id" is a good idea, as in "user:1000".
@@ -2612,7 +2612,7 @@ func redisKeyForRepoNamespacedName(name types.NamespacedName) (string, error) {
 	return fmt.Sprintf("%s:%s:%s", fluxHelmRepositories, name.Namespace, name.Name), nil
 }
 
-func newHttpRepoAndServeIndex(repoIndex, repoName, repoNamespace string, replaceUrls map[string]string, secretRef string) (*httptest.Server, *sourcev1beta2.HelmRepository, error) {
+func newHttpRepoAndServeIndex(repoIndex, repoName, repoNamespace string, replaceUrls map[string]string, secretRef string) (*httptest.Server, *sourcev1.HelmRepository, error) {
 	indexYAMLBytes, err := os.ReadFile(repoIndex)
 	if err != nil {
 		return nil, nil, err
@@ -2631,7 +2631,7 @@ func newHttpRepoAndServeIndex(repoIndex, repoName, repoNamespace string, replace
 		fmt.Fprintln(w, string(indexYAMLBytes))
 	}))
 
-	repoSpec := &sourcev1beta2.HelmRepositorySpec{
+	repoSpec := &sourcev1.HelmRepositorySpec{
 		URL:      "https://example.repo.com/charts",
 		Interval: metav1.Duration{Duration: 1 * time.Minute},
 	}
@@ -2644,7 +2644,7 @@ func newHttpRepoAndServeIndex(repoIndex, repoName, repoNamespace string, replace
 	revision := "651f952130ea96823711d08345b85e82be011dc6"
 	sz := int64(31989)
 
-	repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+	repoStatus := &sourcev1.HelmRepositoryStatus{
 		Artifact: &sourcev1.Artifact{
 			Path:           fmt.Sprintf("helmrepository/%s/%s/index-%s.yaml", repoNamespace, repoName, revision),
 			Digest:         revision,
@@ -2669,16 +2669,16 @@ func newHttpRepoAndServeIndex(repoIndex, repoName, repoNamespace string, replace
 	return ts, &repo, nil
 }
 
-func newOciRepo(repoName, repoNamespace, repoUrl string) (*sourcev1beta2.HelmRepository, error) {
+func newOciRepo(repoName, repoNamespace, repoUrl string) (*sourcev1.HelmRepository, error) {
 	timeout := metav1.Duration{Duration: 60 * time.Second}
-	repoSpec := &sourcev1beta2.HelmRepositorySpec{
+	repoSpec := &sourcev1.HelmRepositorySpec{
 		URL:      repoUrl,
 		Interval: metav1.Duration{Duration: 1 * time.Minute},
 		Timeout:  &timeout,
 		Type:     "oci",
 	}
 
-	repoStatus := &sourcev1beta2.HelmRepositoryStatus{
+	repoStatus := &sourcev1.HelmRepositoryStatus{
 		Conditions: []metav1.Condition{
 			{
 				Type:               fluxmeta.ReadyCondition,
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server.go
index 53fac6474..ef3d506b3 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server.go
@@ -13,8 +13,8 @@ import (
 
 	"github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/plugins/pkg/helm"
 
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	authorizationv1 "k8s.io/api/authorization/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
@@ -89,11 +89,11 @@ func NewServer(configGetter core.KubernetesConfigGetter, kubeappsCluster string,
 
 		// register the GitOps Toolkit schema definitions
 		scheme := runtime.NewScheme()
-		err = sourcev1beta2.AddToScheme(scheme)
+		err = sourcev1.AddToScheme(scheme)
 		if err != nil {
 			log.Fatalf("%s", err)
 		}
-		err = helmv2beta2.AddToScheme(scheme)
+		err = helmv2.AddToScheme(scheme)
 		if err != nil {
 			log.Fatalf("%s", err)
 		}
@@ -112,11 +112,11 @@ func NewServer(configGetter core.KubernetesConfigGetter, kubeappsCluster string,
 			OnGetFunc:    s.onGetRepo,
 			OnDeleteFunc: s.onDeleteRepo,
 			OnResyncFunc: s.onResync,
-			NewObjFunc:   func() ctrlclient.Object { return &sourcev1beta2.HelmRepository{} },
-			NewListFunc:  func() ctrlclient.ObjectList { return &sourcev1beta2.HelmRepositoryList{} },
+			NewObjFunc:   func() ctrlclient.Object { return &sourcev1.HelmRepository{} },
+			NewListFunc:  func() ctrlclient.ObjectList { return &sourcev1.HelmRepositoryList{} },
 			ListItemsFunc: func(ol ctrlclient.ObjectList) []ctrlclient.Object {
-				if hl, ok := ol.(*sourcev1beta2.HelmRepositoryList); !ok {
-					log.Errorf("Expected: *sourcev1beta2.HelmRepositoryList, got: %T", ol)
+				if hl, ok := ol.(*sourcev1.HelmRepositoryList); !ok {
+					log.Errorf("Expected: *sourcev1.HelmRepositoryList, got: %T", ol)
 					return nil
 				} else {
 					ret := make([]ctrlclient.Object, len(hl.Items))
@@ -619,7 +619,7 @@ func (s *Server) GetPackageRepositoryPermissions(ctx context.Context, request *c
 	}
 
 	resource := schema.GroupResource{
-		Group:    sourcev1beta2.GroupVersion.Group,
+		Group:    sourcev1.GroupVersion.Group,
 		Resource: fluxHelmRepositories,
 	}
 
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server_test.go
index abed61c06..14278399e 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/server_test.go
@@ -13,9 +13,9 @@ import (
 	"time"
 
 	"github.com/bufbuild/connect-go"
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
 	fluxmeta "github.com/fluxcd/pkg/apis/meta"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/go-redis/redis/v8"
 	"github.com/go-redis/redismock/v8"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
@@ -46,13 +46,13 @@ import (
 func TestGetAvailablePackagesStatus(t *testing.T) {
 	testCases := []struct {
 		name       string
-		repo       sourcev1beta2.HelmRepository
+		repo       sourcev1.HelmRepository
 		statusCode codes.Code
 	}{
 		{
 			name: "returns without error if response status does not contain conditions",
 			repo: newRepo("test", "default",
-				&sourcev1beta2.HelmRepositorySpec{
+				&sourcev1.HelmRepositorySpec{
 					URL:      "http://example.com",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				},
@@ -62,21 +62,21 @@ func TestGetAvailablePackagesStatus(t *testing.T) {
 		{
 			name: "returns without error if response status does not contain conditions (2)",
 			repo: newRepo("test", "default",
-				&sourcev1beta2.HelmRepositorySpec{
+				&sourcev1.HelmRepositorySpec{
 					URL:      "http://example.com",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				},
-				&sourcev1beta2.HelmRepositoryStatus{}),
+				&sourcev1.HelmRepositoryStatus{}),
 			statusCode: codes.OK,
 		},
 		{
 			name: "returns without error if response does not contain ready repos",
 			repo: newRepo("test", "default",
-				&sourcev1beta2.HelmRepositorySpec{
+				&sourcev1.HelmRepositorySpec{
 					URL:      "http://example.com",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				},
-				&sourcev1beta2.HelmRepositoryStatus{
+				&sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							Type:   fluxmeta.ReadyCondition,
@@ -91,7 +91,7 @@ func TestGetAvailablePackagesStatus(t *testing.T) {
 			name: "returns without error if repo object does not contain namespace",
 			repo: newRepo("test", "",
 				nil,
-				&sourcev1beta2.HelmRepositoryStatus{
+				&sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							Type:   fluxmeta.ReadyCondition,
@@ -106,7 +106,7 @@ func TestGetAvailablePackagesStatus(t *testing.T) {
 			name: "returns without error if repo object contains default spec",
 			repo: newRepo("test", "default",
 				nil,
-				&sourcev1beta2.HelmRepositoryStatus{
+				&sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							Type:   fluxmeta.ReadyCondition,
@@ -120,8 +120,8 @@ func TestGetAvailablePackagesStatus(t *testing.T) {
 		{
 			name: "returns without error if repo object does not contain spec url",
 			repo: newRepo("test", "default",
-				&sourcev1beta2.HelmRepositorySpec{},
-				&sourcev1beta2.HelmRepositoryStatus{
+				&sourcev1.HelmRepositorySpec{},
+				&sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							Type:   fluxmeta.ReadyCondition,
@@ -135,11 +135,11 @@ func TestGetAvailablePackagesStatus(t *testing.T) {
 		{
 			name: "returns without error if repo object does not contain status url",
 			repo: newRepo("test", "default",
-				&sourcev1beta2.HelmRepositorySpec{
+				&sourcev1.HelmRepositorySpec{
 					URL:      "http://example.com",
 					Interval: metav1.Duration{Duration: 1 * time.Minute},
 				},
-				&sourcev1beta2.HelmRepositoryStatus{
+				&sourcev1.HelmRepositoryStatus{
 					Conditions: []metav1.Condition{
 						{
 							Type:   fluxmeta.ReadyCondition,
@@ -154,7 +154,7 @@ func TestGetAvailablePackagesStatus(t *testing.T) {
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			s, mock, err := newSimpleServerWithRepos(t, []sourcev1beta2.HelmRepository{tc.repo})
+			s, mock, err := newSimpleServerWithRepos(t, []sourcev1.HelmRepository{tc.repo})
 			if err != nil {
 				t.Fatalf("error instantiating the server: %v", err)
 			}
@@ -204,11 +204,11 @@ type testSpecChartWithUrl struct {
 	numRetries int
 }
 
-func newSimpleServerWithRepos(t *testing.T, repos []sourcev1beta2.HelmRepository) (*Server, redismock.ClientMock, error) {
+func newSimpleServerWithRepos(t *testing.T, repos []sourcev1.HelmRepository) (*Server, redismock.ClientMock, error) {
 	return newServerWithRepos(t, repos, nil, nil)
 }
 
-func newServerWithRepos(t *testing.T, repos []sourcev1beta2.HelmRepository, charts []testSpecChartWithUrl, secrets []runtime.Object) (*Server, redismock.ClientMock, error) {
+func newServerWithRepos(t *testing.T, repos []sourcev1.HelmRepository, charts []testSpecChartWithUrl, secrets []runtime.Object) (*Server, redismock.ClientMock, error) {
 	typedClient := typfake.NewSimpleClientset(secrets...)
 
 	// ref https://stackoverflow.com/questions/68794562/kubernetes-fake-client-doesnt-handle-generatename-in-objectmeta/68794563#68794563
@@ -243,7 +243,7 @@ func newServerWithRepos(t *testing.T, repos []sourcev1beta2.HelmRepository, char
 	return newServer(t, clientGetter, nil, repos, charts)
 }
 
-func newServerWithChartsAndReleases(t *testing.T, actionConfig *action.Configuration, charts []sourcev1beta2.HelmChart, releases []helmv2beta2.HelmRelease) (*Server, redismock.ClientMock, error) {
+func newServerWithChartsAndReleases(t *testing.T, actionConfig *action.Configuration, charts []sourcev1.HelmChart, releases []helmv2.HelmRelease) (*Server, redismock.ClientMock, error) {
 	typedClient := typfake.NewSimpleClientset()
 	// Creating an authorized clientGetter
 	typedClient.PrependReactor("create", "selfsubjectaccessreviews", func(action k8stesting.Action) (handled bool, ret runtime.Object, err error) {
@@ -316,7 +316,7 @@ func newHelmActionConfig(t *testing.T, namespace string, rels []helmReleaseStub)
 func newServer(t *testing.T,
 	clientGetter clientgetter.ClientProviderInterface,
 	actionConfig *action.Configuration,
-	repos []sourcev1beta2.HelmRepository,
+	repos []sourcev1.HelmRepository,
 	charts []testSpecChartWithUrl) (*Server, redismock.ClientMock, error) {
 
 	stopCh := make(chan struct{})
@@ -360,11 +360,11 @@ func newServer(t *testing.T,
 		OnGetFunc:    sink.onGetRepo,
 		OnDeleteFunc: sink.onDeleteRepo,
 		OnResyncFunc: sink.onResync,
-		NewObjFunc:   func() ctrlclient.Object { return &sourcev1beta2.HelmRepository{} },
-		NewListFunc:  func() ctrlclient.ObjectList { return &sourcev1beta2.HelmRepositoryList{} },
+		NewObjFunc:   func() ctrlclient.Object { return &sourcev1.HelmRepository{} },
+		NewListFunc:  func() ctrlclient.ObjectList { return &sourcev1.HelmRepositoryList{} },
 		ListItemsFunc: func(ol ctrlclient.ObjectList) []ctrlclient.Object {
-			if hl, ok := ol.(*sourcev1beta2.HelmRepositoryList); !ok {
-				t.Fatalf("Expected: *sourcev1beta2.HelmRepositoryList, got: %T", ol)
+			if hl, ok := ol.(*sourcev1.HelmRepositoryList); !ok {
+				t.Fatalf("Expected: *sourcev1.HelmRepositoryList, got: %T", ol)
 				return nil
 			} else {
 				ret := make([]ctrlclient.Object, len(hl.Items))
@@ -410,8 +410,8 @@ func newServer(t *testing.T,
 func seedRepoCacheWithRepos(t *testing.T,
 	mock redismock.ClientMock,
 	sink repoEventSink,
-	repos []sourcev1beta2.HelmRepository) map[string]sourcev1beta2.HelmRepository {
-	okRepos := make(map[string]sourcev1beta2.HelmRepository)
+	repos []sourcev1.HelmRepository) map[string]sourcev1.HelmRepository {
+	okRepos := make(map[string]sourcev1.HelmRepository)
 	for _, r := range repos {
 		key, err := redisKeyForRepo(r)
 		if err != nil {
@@ -441,7 +441,7 @@ func seedChartCacheWithCharts(t *testing.T,
 	mock redismock.ClientMock,
 	sink repoEventSink,
 	stopCh <-chan struct{},
-	repos map[string]sourcev1beta2.HelmRepository,
+	repos map[string]sourcev1.HelmRepository,
 	charts []testSpecChartWithUrl) (*cache.ChartCache, func(), error) {
 	t.Logf("+seedChartCacheWithCharts(%v)", charts)
 
diff --git a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/test_util_test.go b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/test_util_test.go
index dfbcb10c8..8109f3f2f 100644
--- a/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/test_util_test.go
+++ b/cmd/kubeapps-apis/plugins/fluxv2/packages/v1alpha1/test_util_test.go
@@ -19,8 +19,8 @@ import (
 
 	k8stesting "k8s.io/client-go/testing"
 
-	helmv2beta2 "github.com/fluxcd/helm-controller/api/v2beta2"
-	sourcev1beta2 "github.com/fluxcd/source-controller/api/v1beta2"
+	helmv2 "github.com/fluxcd/helm-controller/api/v2"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1"
 	"github.com/google/go-cmp/cmp"
 	"github.com/google/go-cmp/cmp/cmpopts"
 	corev1 "github.com/vmware-tanzu/kubeapps/cmd/kubeapps-apis/gen/core/packages/v1alpha1"
@@ -305,8 +305,8 @@ func setSecretOwnerRef(repoName string, secret *apiv1.Secret) *apiv1.Secret {
 	tRue := true
 	secret.OwnerReferences = []metav1.OwnerReference{
 		{
-			APIVersion:         sourcev1beta2.GroupVersion.String(),
-			Kind:               sourcev1beta2.HelmRepositoryKind,
+			APIVersion:         sourcev1.GroupVersion.String(),
+			Kind:               sourcev1.HelmRepositoryKind,
 			Name:               repoName,
 			Controller:         &tRue,
 			BlockOwnerDeletion: &tRue,
@@ -353,45 +353,45 @@ func repoRef(id, namespace string) *corev1.PackageRepositoryReference {
 	}
 }
 
-func newCtrlClient(repos []sourcev1beta2.HelmRepository, charts []sourcev1beta2.HelmChart, releases []helmv2beta2.HelmRelease) withWatchWrapper {
+func newCtrlClient(repos []sourcev1.HelmRepository, charts []sourcev1.HelmChart, releases []helmv2.HelmRelease) withWatchWrapper {
 	// register the flux GitOps Toolkit schema definitions
 	scheme := runtime.NewScheme()
-	err := sourcev1beta2.AddToScheme(scheme)
+	err := sourcev1.AddToScheme(scheme)
 	if err != nil {
 		log.Fatal(err)
 	}
-	err = helmv2beta2.AddToScheme(scheme)
+	err = helmv2.AddToScheme(scheme)
 	if err != nil {
 		log.Fatal(err)
 	}
 
-	rm := apimeta.NewDefaultRESTMapper([]schema.GroupVersion{sourcev1beta2.GroupVersion, helmv2beta2.GroupVersion})
+	rm := apimeta.NewDefaultRESTMapper([]schema.GroupVersion{sourcev1.GroupVersion, helmv2.GroupVersion})
 	rm.Add(schema.GroupVersionKind{
-		Group:   sourcev1beta2.GroupVersion.Group,
-		Version: sourcev1beta2.GroupVersion.Version,
-		Kind:    sourcev1beta2.HelmRepositoryKind},
+		Group:   sourcev1.GroupVersion.Group,
+		Version: sourcev1.GroupVersion.Version,
+		Kind:    sourcev1.HelmRepositoryKind},
 		apimeta.RESTScopeNamespace)
 	rm.Add(schema.GroupVersionKind{
-		Group:   sourcev1beta2.GroupVersion.Group,
-		Version: sourcev1beta2.GroupVersion.Version,
-		Kind:    sourcev1beta2.HelmChartKind},
+		Group:   sourcev1.GroupVersion.Group,
+		Version: sourcev1.GroupVersion.Version,
+		Kind:    sourcev1.HelmChartKind},
 		apimeta.RESTScopeNamespace)
 	rm.Add(schema.GroupVersionKind{
-		Group:   helmv2beta2.GroupVersion.Group,
-		Version: helmv2beta2.GroupVersion.Version,
-		Kind:    helmv2beta2.HelmReleaseKind},
+		Group:   helmv2.GroupVersion.Group,
+		Version: helmv2.GroupVersion.Version,
+		Kind:    helmv2.HelmReleaseKind},
 		apimeta.RESTScopeNamespace)
 
 	ctrlClientBuilder := ctrlfake.NewClientBuilder().WithScheme(scheme).WithRESTMapper(rm)
 	initLists := []client.ObjectList{}
 	if len(repos) > 0 {
-		initLists = append(initLists, &sourcev1beta2.HelmRepositoryList{Items: repos})
+		initLists = append(initLists, &sourcev1.HelmRepositoryList{Items: repos})
 	}
 	if len(charts) > 0 {
-		initLists = append(initLists, &sourcev1beta2.HelmChartList{Items: charts})
+		initLists = append(initLists, &sourcev1.HelmChartList{Items: charts})
 	}
 	if len(releases) > 0 {
-		initLists = append(initLists, &helmv2beta2.HelmReleaseList{Items: releases})
+		initLists = append(initLists, &helmv2.HelmReleaseList{Items: releases})
 	}
 	if len(initLists) > 0 {
 		ctrlClientBuilder = ctrlClientBuilder.WithLists(initLists...)
diff --git a/go.mod b/go.mod
index 657034425..a164a47fe 100644
--- a/go.mod
+++ b/go.mod
@@ -3,7 +3,9 @@
 
 module github.com/vmware-tanzu/kubeapps
 
-go 1.22
+go 1.22.0
+
+toolchain go1.22.2
 
 require (
 	carvel.dev/vendir v0.40.1
@@ -18,11 +20,11 @@ require (
 	github.com/disintegration/imaging v1.6.2
 	github.com/distribution/reference v0.6.0
 	github.com/docker/cli v27.0.3+incompatible
-	github.com/fluxcd/helm-controller/api v0.37.4
-	github.com/fluxcd/pkg/apis/meta v1.4.0
+	github.com/fluxcd/helm-controller/api v1.0.1
+	github.com/fluxcd/pkg/apis/meta v1.5.0
 	github.com/fluxcd/pkg/oci v0.36.0
 	github.com/fluxcd/pkg/version v0.3.0
-	github.com/fluxcd/source-controller/api v1.2.5
+	github.com/fluxcd/source-controller/api v1.3.0
 	github.com/go-redis/redis/v8 v8.11.5
 	github.com/go-redis/redismock/v8 v8.11.5
 	github.com/google/go-cmp v0.6.0
@@ -51,18 +53,18 @@ require (
 	google.golang.org/protobuf v1.34.2
 	gopkg.in/yaml.v3 v3.0.1
 	helm.sh/helm/v3 v3.14.4
-	k8s.io/api v0.29.3
-	k8s.io/apiextensions-apiserver v0.29.3
-	k8s.io/apimachinery v0.29.3
-	k8s.io/apiserver v0.29.3
+	k8s.io/api v0.30.0
+	k8s.io/apiextensions-apiserver v0.30.0
+	k8s.io/apimachinery v0.30.0
+	k8s.io/apiserver v0.30.0
 	k8s.io/cli-runtime v0.29.3
-	k8s.io/client-go v0.29.3
+	k8s.io/client-go v0.30.0
 	k8s.io/klog/v2 v2.130.1
 	k8s.io/kubectl v0.29.3
 	k8s.io/utils v0.0.0-20240310230437-4693a0247e57
 	oras.land/oras-go v1.2.5
 	oras.land/oras-go/v2 v2.5.0
-	sigs.k8s.io/controller-runtime v0.17.3
+	sigs.k8s.io/controller-runtime v0.18.1
 	sigs.k8s.io/yaml v1.4.0
 )
 
@@ -113,13 +115,13 @@ require (
 	github.com/docker/go-metrics v0.0.1 // indirect
 	github.com/emicklei/go-restful/v3 v3.11.0 // indirect
 	github.com/evanphx/json-patch v5.7.0+incompatible // indirect
-	github.com/evanphx/json-patch/v5 v5.8.0 // indirect
+	github.com/evanphx/json-patch/v5 v5.9.0 // indirect
 	github.com/exponent-io/jsonpath v0.0.0-20210407135951-1de76d718b3f // indirect
 	github.com/fatih/camelcase v1.0.0 // indirect
 	github.com/fatih/color v1.15.0 // indirect
 	github.com/felixge/httpsnoop v1.0.4 // indirect
-	github.com/fluxcd/pkg/apis/acl v0.1.0 // indirect
-	github.com/fluxcd/pkg/apis/kustomize v1.3.0 // indirect
+	github.com/fluxcd/pkg/apis/acl v0.3.0 // indirect
+	github.com/fluxcd/pkg/apis/kustomize v1.5.0 // indirect
 	github.com/fsnotify/fsnotify v1.7.0 // indirect
 	github.com/fvbommel/sortorder v1.1.0 // indirect
 	github.com/go-errors/errors v1.4.2 // indirect
@@ -227,8 +229,8 @@ require (
 	gopkg.in/inf.v0 v0.9.1 // indirect
 	gopkg.in/ini.v1 v1.67.0 // indirect
 	gopkg.in/yaml.v2 v2.4.0 // indirect
-	k8s.io/component-base v0.29.3 // indirect
-	k8s.io/kube-openapi v0.0.0-20231113174909-778a5567bc1e // indirect
+	k8s.io/component-base v0.30.0 // indirect
+	k8s.io/kube-openapi v0.0.0-20240228011516-70dd3763d340 // indirect
 	sigs.k8s.io/json v0.0.0-20221116044647-bc3834ca7abd // indirect
 	sigs.k8s.io/kustomize/api v0.13.5-0.20230601165947-6ce0bf390ce3 // indirect
 	sigs.k8s.io/kustomize/kyaml v0.14.3-0.20230601165947-6ce0bf390ce3 // indirect
diff --git a/go.sum b/go.sum
index c6916998b..415e32cbb 100644
--- a/go.sum
+++ b/go.sum
@@ -245,8 +245,8 @@ github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7
 github.com/envoyproxy/protoc-gen-validate v0.6.2/go.mod h1:2t7qjJNvHPx8IjnBOzl9E9/baC+qXE/TeeyBRzgJDws=
 github.com/evanphx/json-patch v5.7.0+incompatible h1:vgGkfT/9f8zE6tvSCe74nfpAVDQ2tG6yudJd8LBksgI=
 github.com/evanphx/json-patch v5.7.0+incompatible/go.mod h1:50XU6AFN0ol/bzJsmQLiYLvXMP4fmwYFNcr97nuDLSk=
-github.com/evanphx/json-patch/v5 v5.8.0 h1:lRj6N9Nci7MvzrXuX6HFzU8XjmhPiXPlsKEy1u0KQro=
-github.com/evanphx/json-patch/v5 v5.8.0/go.mod h1:VNkHZ/282BpEyt/tObQO8s5CMPmYYq14uClGH4abBuQ=
+github.com/evanphx/json-patch/v5 v5.9.0 h1:kcBlZQbplgElYIlo/n1hJbls2z/1awpXxpRi0/FOJfg=
+github.com/evanphx/json-patch/v5 v5.9.0/go.mod h1:VNkHZ/282BpEyt/tObQO8s5CMPmYYq14uClGH4abBuQ=
 github.com/exponent-io/jsonpath v0.0.0-20210407135951-1de76d718b3f h1:Wl78ApPPB2Wvf/TIe2xdyJxTlb6obmF18d8QdkxNDu4=
 github.com/exponent-io/jsonpath v0.0.0-20210407135951-1de76d718b3f/go.mod h1:OSYXu++VVOHnXeitef/D8n/6y4QV8uLHSFXX4NeXMGc=
 github.com/fatih/camelcase v1.0.0 h1:hxNvNX/xYBp0ovncs8WyWZrOrpBNub/JfaMvbURyft8=
@@ -258,20 +258,22 @@ github.com/fatih/color v1.15.0 h1:kOqh6YHBtK8aywxGerMG2Eq3H6Qgoqeo13Bk2Mv/nBs=
 github.com/fatih/color v1.15.0/go.mod h1:0h5ZqXfHYED7Bhv2ZJamyIOUej9KtShiJESRwBDUSsw=
 github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
 github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
-github.com/fluxcd/helm-controller/api v0.37.4 h1:rkBMqYXexyf1s5BS8QpxGi691DsCi+yugIFCM5fNKLU=
-github.com/fluxcd/helm-controller/api v0.37.4/go.mod h1:KFdP5Lbrc4Vv+Jt4xRj6UUo3qiwdBqBPl1xiiAnBe9c=
-github.com/fluxcd/pkg/apis/acl v0.1.0 h1:EoAl377hDQYL3WqanWCdifauXqXbMyFuK82NnX6pH4Q=
-github.com/fluxcd/pkg/apis/acl v0.1.0/go.mod h1:zfEZzz169Oap034EsDhmCAGgnWlcWmIObZjYMusoXS8=
-github.com/fluxcd/pkg/apis/kustomize v1.3.0 h1:qvB46CfaOWcL1SyR2RiVWN/j7/035D0OtB1ltLN7rgI=
-github.com/fluxcd/pkg/apis/kustomize v1.3.0/go.mod h1:PCXf5kktTzNav0aH2Ns3jsowqwmA9xTcsrEOoPzx/K8=
-github.com/fluxcd/pkg/apis/meta v1.4.0 h1:nNdgB6FFHP3cubxZCViaCFDUVlAbpq9+hvKEIveOGMg=
-github.com/fluxcd/pkg/apis/meta v1.4.0/go.mod h1:81sZ01ShTuLc1C3M1dFJNkINareBysvmrO1b8zJFFKs=
+github.com/fluxcd/helm-controller/api v1.0.1 h1:Gn9qEVuif6D5+gHmVwTEZkR4+nmLOcOhKx4Sw2gL2EA=
+github.com/fluxcd/helm-controller/api v1.0.1/go.mod h1:/6AD5a2qjo/ttxVM8GR33syLZwqigta60DCLdy8GrME=
+github.com/fluxcd/pkg/apis/acl v0.3.0 h1:UOrKkBTOJK+OlZX7n8rWt2rdBmDCoTK+f5TY2LcZi8A=
+github.com/fluxcd/pkg/apis/acl v0.3.0/go.mod h1:WVF9XjSMVBZuU+HTTiSebGAWMgM7IYexFLyVWbK9bNY=
+github.com/fluxcd/pkg/apis/kustomize v1.5.0 h1:ah4sfqccnio+/5Edz/tVz6LetFhiBoDzXAElj6fFCzU=
+github.com/fluxcd/pkg/apis/kustomize v1.5.0/go.mod h1:nEzhnhHafhWOUUV8VMFLojUOH+HHDEsL75y54mt/c30=
+github.com/fluxcd/pkg/apis/meta v1.5.0 h1:/G82d2Az5D9op3F+wJUpD8jw/eTV0suM6P7+cSURoUM=
+github.com/fluxcd/pkg/apis/meta v1.5.0/go.mod h1:Y3u7JomuuKtr5fvP1Iji2/50FdRe5GcBug2jawNVkdM=
 github.com/fluxcd/pkg/oci v0.36.0 h1:bC+Qkm6p8rN72McArNwYFjI9bt7M2vn6mnt7i/vOWv0=
 github.com/fluxcd/pkg/oci v0.36.0/go.mod h1:ocWsg1tjhjlIpdpdw0xZz7q9YQH8YzcrN1wi+Az0t7E=
 github.com/fluxcd/pkg/version v0.3.0 h1:+GSU3QKQK66Y09+cQMAEoyh7j4S0ZimXF6MyGgJwZB4=
 github.com/fluxcd/pkg/version v0.3.0/go.mod h1:NO3/EuKNn9g6aw9NN85Hdrz+5CVx90KZC6rPsOmgvVI=
 github.com/fluxcd/source-controller/api v1.2.5 h1:MgGrOfPh7Grhl40GUM9lEs+lmgTx3hLAwI0MVqaJkQ8=
 github.com/fluxcd/source-controller/api v1.2.5/go.mod h1:j3QSHpIPBP5sjaGIkVtsgWCx8JcOmcsutRmdJmRMOZg=
+github.com/fluxcd/source-controller/api v1.3.0 h1:Z5Lq0aJY87yg0cQDEuwGLKS60GhdErCHtsi546HUt10=
+github.com/fluxcd/source-controller/api v1.3.0/go.mod h1:+tfd0vltjcVs/bbnq9AlYR9AAHSVfM/Z4v4TpQmdJf4=
 github.com/foxcpp/go-mockdns v1.0.0 h1:7jBqxd3WDWwi/6WhDvacvH1XsN3rOLXyHM1uhvIx6FI=
 github.com/foxcpp/go-mockdns v1.0.0/go.mod h1:lgRN6+KxQBawyIghpnl5CezHFGS9VLzvtVlwxvzXTQ4=
 github.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=
@@ -652,8 +654,8 @@ github.com/onsi/ginkgo v1.16.4/go.mod h1:dX+/inL/fNMqNlz0e9LfyB9TswhZpCVdJM/Z6Vv
 github.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=
 github.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=
 github.com/onsi/ginkgo/v2 v2.0.0/go.mod h1:vw5CSIxN1JObi/U8gcbwft7ZxR2dgaR70JSE3/PpL4c=
-github.com/onsi/ginkgo/v2 v2.14.0 h1:vSmGj2Z5YPb9JwCWT6z6ihcUvDhuXLc3sJiqd3jMKAY=
-github.com/onsi/ginkgo/v2 v2.14.0/go.mod h1:JkUdW7JkN0V6rFvsHcJ478egV3XH9NxpD27Hal/PhZw=
+github.com/onsi/ginkgo/v2 v2.17.1 h1:V++EzdbhI4ZV4ev0UTIj0PzhzOcReJFyJaLjtSF55M8=
+github.com/onsi/ginkgo/v2 v2.17.1/go.mod h1:llBI3WDLL9Z6taip6f33H76YcWtJv+7R3HigUjbIBOs=
 github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
 github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
 github.com/onsi/gomega v1.17.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=
@@ -1380,24 +1382,24 @@ honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWh
 honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
 honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
 honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
-k8s.io/api v0.29.3 h1:2ORfZ7+bGC3YJqGpV0KSDDEVf8hdGQ6A03/50vj8pmw=
-k8s.io/api v0.29.3/go.mod h1:y2yg2NTyHUUkIoTC+phinTnEa3KFM6RZ3szxt014a80=
-k8s.io/apiextensions-apiserver v0.29.3 h1:9HF+EtZaVpFjStakF4yVufnXGPRppWFEQ87qnO91YeI=
-k8s.io/apiextensions-apiserver v0.29.3/go.mod h1:po0XiY5scnpJfFizNGo6puNU6Fq6D70UJY2Cb2KwAVc=
-k8s.io/apimachinery v0.29.3 h1:2tbx+5L7RNvqJjn7RIuIKu9XTsIZ9Z5wX2G22XAa5EU=
-k8s.io/apimachinery v0.29.3/go.mod h1:hx/S4V2PNW4OMg3WizRrHutyB5la0iCUbZym+W0EQIU=
-k8s.io/apiserver v0.29.3 h1:xR7ELlJ/BZSr2n4CnD3lfA4gzFivh0wwfNfz9L0WZcE=
-k8s.io/apiserver v0.29.3/go.mod h1:hrvXlwfRulbMbBgmWRQlFru2b/JySDpmzvQwwk4GUOs=
+k8s.io/api v0.30.0 h1:siWhRq7cNjy2iHssOB9SCGNCl2spiF1dO3dABqZ8niA=
+k8s.io/api v0.30.0/go.mod h1:OPlaYhoHs8EQ1ql0R/TsUgaRPhpKNxIMrKQfWUp8QSE=
+k8s.io/apiextensions-apiserver v0.30.0 h1:jcZFKMqnICJfRxTgnC4E+Hpcq8UEhT8B2lhBcQ+6uAs=
+k8s.io/apiextensions-apiserver v0.30.0/go.mod h1:N9ogQFGcrbWqAY9p2mUAL5mGxsLqwgtUce127VtRX5Y=
+k8s.io/apimachinery v0.30.0 h1:qxVPsyDM5XS96NIh9Oj6LavoVFYff/Pon9cZeDIkHHA=
+k8s.io/apimachinery v0.30.0/go.mod h1:iexa2somDaxdnj7bha06bhb43Zpa6eWH8N8dbqVjTUc=
+k8s.io/apiserver v0.30.0 h1:QCec+U72tMQ+9tR6A0sMBB5Vh6ImCEkoKkTDRABWq6M=
+k8s.io/apiserver v0.30.0/go.mod h1:smOIBq8t0MbKZi7O7SyIpjPsiKJ8qa+llcFCluKyqiY=
 k8s.io/cli-runtime v0.29.3 h1:r68rephmmytoywkw2MyJ+CxjpasJDQY7AGc3XY2iv1k=
 k8s.io/cli-runtime v0.29.3/go.mod h1:aqVUsk86/RhaGJwDhHXH0jcdqBrgdF3bZWk4Z9D4mkM=
-k8s.io/client-go v0.29.3 h1:R/zaZbEAxqComZ9FHeQwOh3Y1ZUs7FaHKZdQtIc2WZg=
-k8s.io/client-go v0.29.3/go.mod h1:tkDisCvgPfiRpxGnOORfkljmS+UrW+WtXAy2fTvXJB0=
-k8s.io/component-base v0.29.3 h1:Oq9/nddUxlnrCuuR2K/jp6aflVvc0uDvxMzAWxnGzAo=
-k8s.io/component-base v0.29.3/go.mod h1:Yuj33XXjuOk2BAaHsIGHhCKZQAgYKhqIxIjIr2UXYio=
+k8s.io/client-go v0.30.0 h1:sB1AGGlhY/o7KCyCEQ0bPWzYDL0pwOZO4vAtTSh/gJQ=
+k8s.io/client-go v0.30.0/go.mod h1:g7li5O5256qe6TYdAMyX/otJqMhIiGgTapdLchhmOaY=
+k8s.io/component-base v0.30.0 h1:cj6bp38g0ainlfYtaOQuRELh5KSYjhKxM+io7AUIk4o=
+k8s.io/component-base v0.30.0/go.mod h1:V9x/0ePFNaKeKYA3bOvIbrNoluTSG+fSJKjLdjOoeXQ=
 k8s.io/klog/v2 v2.130.1 h1:n9Xl7H1Xvksem4KFG4PYbdQCQxqc/tTUyrgXaOhHSzk=
 k8s.io/klog/v2 v2.130.1/go.mod h1:3Jpz1GvMt720eyJH1ckRHK1EDfpxISzJ7I9OYgaDtPE=
-k8s.io/kube-openapi v0.0.0-20231113174909-778a5567bc1e h1:snPmy96t93RredGRjKfMFt+gvxuVAncqSAyBveJtr4Q=
-k8s.io/kube-openapi v0.0.0-20231113174909-778a5567bc1e/go.mod h1:AsvuZPBlUDVuCdzJ87iajxtXuR9oktsTctW/R9wwouA=
+k8s.io/kube-openapi v0.0.0-20240228011516-70dd3763d340 h1:BZqlfIlq5YbRMFko6/PM7FjZpUb45WallggurYhKGag=
+k8s.io/kube-openapi v0.0.0-20240228011516-70dd3763d340/go.mod h1:yD4MZYeKMBwQKVht279WycxKyM84kkAx2DPrTXaeb98=
 k8s.io/kubectl v0.29.3 h1:RuwyyIU42MAISRIePaa8Q7A3U74Q9P4MoJbDFz9o3us=
 k8s.io/kubectl v0.29.3/go.mod h1:yCxfY1dbwgVdEt2zkJ6d5NNLOhhWgTyrqACIoFhpdd4=
 k8s.io/utils v0.0.0-20240310230437-4693a0247e57 h1:gbqbevonBh57eILzModw6mrkbwM0gQBEuevE/AaBsHY=
@@ -1409,8 +1411,8 @@ oras.land/oras-go/v2 v2.5.0/go.mod h1:z4eisnLP530vwIOUOJeBIj0aGI0L1C3d53atvCBqZH
 rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
 rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
 rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
-sigs.k8s.io/controller-runtime v0.17.3 h1:65QmN7r3FWgTxDMz9fvGnO1kbf2nu+acg9p2R9oYYYk=
-sigs.k8s.io/controller-runtime v0.17.3/go.mod h1:N0jpP5Lo7lMTF9aL56Z/B2oWBJjey6StQM0jRbKQXtY=
+sigs.k8s.io/controller-runtime v0.18.1 h1:RpWbigmuiylbxOCLy0tGnq1cU1qWPwNIQzoJk+QeJx4=
+sigs.k8s.io/controller-runtime v0.18.1/go.mod h1:tuAt1+wbVsXIT8lPtk5RURxqAnq7xkpv2Mhttslg7Hw=
 sigs.k8s.io/json v0.0.0-20221116044647-bc3834ca7abd h1:EDPBXCAspyGV4jQlpZSudPeMmr1bNJefnuqLsRAsHZo=
 sigs.k8s.io/json v0.0.0-20221116044647-bc3834ca7abd/go.mod h1:B8JuhiUyNFVKdsE8h686QcCxMaH6HrOAZj4vswFpcB0=
 sigs.k8s.io/kustomize/api v0.13.5-0.20230601165947-6ce0bf390ce3 h1:XX3Ajgzov2RKUdc5jW3t5jwY7Bo7dcRm+tFxT+NfgY0=
